package block

type FactoryTemplateParams struct {
	Package                string
	Type                   string
	Name                   string
	HasForeignID           bool
	Stages                 []string
	BlockTypes             map[string]string
	FactoryTypes           map[string]string
	IDField                *Field
	ValueField             *Field
	Fields                 []*Field
	NodeValueFunctionNames map[string]string
	EvalFieldsCnt          int
}

const factoryTemplate = `
// Code generated by ocl generate. DO NOT EDIT.
package {{.Package}}

import (
	"errors"
	"fmt"
	"strings"

	"github.com/opsidian/ocl/ocl"
	"github.com/opsidian/ocl/util"
	"github.com/opsidian/parsley/parsley"
)

{{ $root := .}}
// New{{$root.Name}}Factory creates a new {{$root.Name}} block factory
func New{{$root.Name}}Factory(
	typeNode parsley.Node,
	idNode parsley.Node,
	paramNodes map[string]parsley.Node,
	blockNodes []parsley.Node,
) (ocl.BlockFactory, parsley.Error) {
	return &{{.Name}}Factory{
		typeNode:   typeNode,
		idNode:     idNode,
		paramNodes: paramNodes,
		blockNodes: blockNodes,
	}, nil
}

// {{$root.Name}}Factory will create and evaluate a {{$root.Name}} block
type {{$root.Name}}Factory struct {
	typeNode   parsley.Node
	idNode     parsley.Node
	paramNodes map[string]parsley.Node
	blockNodes []parsley.Node
	shortFormat bool
}

// CreateBlock creates a new {{$root.Name}} block
func (f *{{$root.Name}}Factory) CreateBlock(parentCtx interface{}) (ocl.Block, interface{}, parsley.Error) {
	var err parsley.Error

	block := &{{$root.Name}}{}

	if block.{{.IDField.Name}}, err = util.NodeStringValue(f.idNode, parentCtx); err != nil {
		return nil, nil, err
	}

	{{ if .HasForeignID }}
	idRegistry := parentCtx.(ocl.IDRegistryAware).GetIDRegistry()
	if !idRegistry.IDExists(id) {
		return nil, nil, parsley.NewErrorf(f.idNode.Pos(), "%q does not exist", id)
	}
	{{ end }}

	ctx := block.Context(parentCtx)

	{{ if .ValueField }}
	if valueNode, ok := f.paramNodes["_value"]; ok {
		f.shortFormat = true

		if block.{{.ValueField.Name}}, err = util.{{index $root.NodeValueFunctionNames .ValueField.Type}}(valueNode, ctx); err != nil {
			return nil, nil, err
		}
	}
	{{ end }}

	if len(f.blockNodes) > 0 {
		var childBlockFactory interface{}
		for _, childBlock := range f.blockNodes {
			if childBlockFactory, err = childBlock.Value(ctx); err != nil {
				return nil, nil, err
			}
			{{- if len .FactoryTypes}}
			switch b := childBlockFactory.(type) {
			{{- range $type, $fieldName := .FactoryTypes -}}
			case {{trimPrefix $type "[]" }}:
				block.{{$fieldName}} = append(block.{{$fieldName}}, b)
			{{- end}}
			default:
				panic(fmt.Sprintf("block type %T is not supported in {{.Name}}, please open a bug ticket", childBlockFactory))
			}
			{{ else }}
			panic(fmt.Sprintf("block type %T is not supported in {{.Name}}, please open a bug ticket", childBlockFactory))
			{{- end }}
		}
	}

	return block, ctx, nil
}

// EvalBlock evaluates all fields belonging to the given stage on a {{$root.Name}} block
func (f *{{$root.Name}}Factory) EvalBlock(ctx interface{}, stage string, res ocl.Block) parsley.Error {
	var err parsley.Error

	if preInterpreter, ok := res.(ocl.BlockPreInterpreter); ok {
		if err = preInterpreter.PreEval(ctx, stage); err != nil {
			return err
		}
	}

	{{ if .EvalFieldsCnt }}
	block, ok := res.(*{{$root.Name}})
	if !ok {
		panic("result must be a type of *{{$root.Name}}")
	}

	validParamNames := map[string]struct{}{
		{{- range $root.Fields -}}{{- if and (not .IsID) (not .IsBlock)}}
		"{{.ParamName}}": struct{}{},
		{{- end -}}{{- end }}
	}

	for paramName, paramNode := range f.paramNodes {
		if !strings.HasPrefix(paramName, "_") {
			if _, valid := validParamNames[paramName]; !valid {
				return parsley.NewError(paramNode.Pos(), fmt.Errorf("%q parameter does not exist", paramName))
			}
		}
	}

	if !f.shortFormat {
		switch stage {
		{{- range $stage := $root.Stages}}
		case "{{$stage}}":
			{{- range $root.Fields -}}{{- if and (eq .Stage $stage) (not .IsID) (not .IsFactory) (not .IsBlock)}}
			if valueNode, ok := f.paramNodes["{{.ParamName}}"]; ok {
				if block.{{.Name}}, err = util.{{index $root.NodeValueFunctionNames .Type}}(valueNode, ctx); err != nil {
					return err
				}
			}{{ if .Required }} else {
				return parsley.NewError(f.typeNode.Pos(), errors.New("{{.ParamName}} parameter is required"))
			}{{ end }}
			{{ end }}{{ end -}}
		{{end -}}
		default:
			panic(fmt.Sprintf("unknown stage: %s", stage))
		}

		switch stage {
			{{- range $stage := $root.Stages}}
			case "{{$stage}}":
				{{- range $root.Fields }}{{ if and (eq .Stage $stage) .IsFactory}}
				var childBlock ocl.Block
				var childBlockCtx interface{}
				for _, childBlockFactory := range block.{{.Name}} {
					if childBlock, childBlockCtx, err = childBlockFactory.CreateBlock(ctx); err != nil {
						return err
					}

					if err = childBlockFactory.EvalBlock(childBlockCtx, stage, childBlock); err != nil {
						return err
					}

					{{ if $root.BlockTypes -}}
					switch b := childBlock.(type) {
					{{- range $type, $fieldName := $root.BlockTypes -}}
					case {{trimPrefix $type "[]" }}:
						block.{{$fieldName}} = append(block.{{$fieldName}}, b)
					{{- end}}
					default:
						panic(fmt.Sprintf("block type %T is not supported in {{.Name}}, please open a bug ticket", childBlock))
					}
					{{ else }}
					panic(fmt.Sprintf("block type %T is not supported in {{.Name}}, please open a bug ticket", childBlock))
					{{- end }}
				}
				{{ end }}{{ end -}}
		{{end -}}
		default:
			panic(fmt.Sprintf("unknown stage: %s", stage))
		}
	}
	{{ end }}

	if postInterpreter, ok := res.(ocl.BlockPostInterpreter); ok {
		if err = postInterpreter.PostEval(ctx, stage); err != nil {
			return err
		}
	}

	return nil
}

// HasForeignID returns true if the block ID is referencing an other block id
func (f *{{$root.Name}}Factory) HasForeignID() bool {
	return {{.HasForeignID}}
}

// HasShortFormat returns true if the block can be defined in the short block format
func (f *{{$root.Name}}Factory) HasShortFormat() bool {
	return {{ if .ValueField }}true{{ else }}false{{ end }}
}
`
