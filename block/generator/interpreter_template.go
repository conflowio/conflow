package generator

type InterpreterTemplateParams struct {
	Package                string
	Type                   string
	Name                   string
	HasForeignID           bool
	Stages                 []string
	ParamTypes             map[string]string
	BlockTypes             map[string]string
	NodeTypes              map[string]string
	IDField                *Field
	ValueField             *Field
	Fields                 []*Field
	NodeValueFunctionNames map[string]string
	EvalFieldsCnt          int
	RequiredFieldsCnt      int
}

const interpreterTemplate = `
// Code generated by Basil. DO NOT EDIT.
package {{.Package}}

import (
	"fmt"

	"github.com/opsidian/basil/basil"
	"github.com/opsidian/basil/util"
	"github.com/opsidian/basil/variable"
	"github.com/opsidian/parsley/parsley"
)

{{ $root := .}}

type {{$root.Name}}Interpreter struct {}

// Create creates a new {{$root.Name}} block
func (i {{$root.Name}}Interpreter) Create(ctx *basil.EvalContext, node basil.BlockNode) basil.Block {
	return &{{$root.Name}}{
		{{.IDField.Name}}: node.ID(),
	}
}

func (i {{$root.Name}}Interpreter) Update(ctx *basil.EvalContext, target basil.Block, blockType basil.ID, n parsley.Node) parsley.Error {
	{{ if .EvalFieldsCnt -}}
	b := target.(*{{$root.Name}})

	switch blockType {
	{{ range $root.Fields -}}
	{{ if .IsParam -}}
	case "{{.ParamName}}":
		var err parsley.Error
		b.{{.Name}}, err = variable.{{index $root.NodeValueFunctionNames .Type}}(n, ctx)
		return err
	{{ end -}}
	{{ if .IsBlock -}}
	case "{{.ParamName}}":
		block, err := n.Value(ctx)
		if err != nil {
			return err
		}
		b.{{.Name}} = append(b.{{.Name}}, block.({{trimPrefix .Type "[]" }}))
		return nil
	{{ end -}}
	{{ end -}}
	}
	{{ end -}}

	panic(fmt.Errorf("unexpected parameter or block %q in {{$root.Name}}Interpreter", blockType))
}

// Params returns with the list of valid parameters
func (i {{$root.Name}}Interpreter) Params() map[basil.ID]string {
	{{ if .ParamTypes -}}
	return map[basil.ID]string{
		{{ range $paramName, $paramType := $root.ParamTypes -}}
		"{{$paramName}}": "{{$paramType}}",
		{{ end -}}
	}
	{{ else -}}
	return nil
	{{ end -}}
}

// RequiredParams returns with the list of required parameters
func (i {{$root.Name}}Interpreter) RequiredParams() map[basil.ID]bool {
	{{ if .RequiredFieldsCnt -}}
	return map[basil.ID]bool{
		{{ range $root.Fields -}}{{ if and (.Required) (not .IsID) (not .IsNode) (not .IsBlock) -}}
		"{{.ParamName}}": false,
		{{ end }}{{ end -}}
	}
	{{ else -}}
	return nil
	{{ end -}}
}

// HasForeignID returns true if the block ID is referencing an other block id
func (i {{$root.Name}}Interpreter) HasForeignID() bool {
	return {{.HasForeignID}}
}

// HasShortFormat returns true if the block can be defined in the short block format
func (i {{$root.Name}}Interpreter) ValueParamName() basil.ID {
	return {{ if .ValueField }}"{{.ValueField.ParamName}}"{{ else }}""{{ end }}
}

// ParseContext returns with the parse context for the block
func (i {{$root.Name}}Interpreter) ParseContext(parentCtx *basil.ParseContext) *basil.ParseContext {
	var nilBlock *{{$root.Name}}
	if b, ok := basil.Block(nilBlock).(basil.ParseContextAware); ok {
		return b.ParseContext(parentCtx)
	}

	return parentCtx
}

func (i {{$root.Name}}Interpreter) Param(target basil.Block, paramName basil.ID) interface{} {
	b := target.(*{{$root.Name}})
	switch paramName {
	{{ range $root.Fields }}{{ if or .IsParam .IsID -}}
	case "{{.ParamName}}":
		return b.{{.Name}}
	{{ end }}{{ end -}}
	default:
		panic(fmt.Errorf("unexpected parameter %q in {{$root.Name}}Interpreter", paramName))
	}
}

`
