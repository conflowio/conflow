// Code generated by Basil. DO NOT EDIT.
package fixtures

import (
	"fmt"

	"github.com/opsidian/basil/basil"
	"github.com/opsidian/basil/variable"
	"github.com/opsidian/parsley/parsley"
)

type BlockWithReferenceInterpreter struct{}

func (i BlockWithReferenceInterpreter) StaticCheck(ctx interface{}, node basil.BlockNode) (string, parsley.Error) {
	validParamNames := map[variable.ID]struct{}{}

	for paramName, paramNode := range node.ParamNodes() {
		if _, valid := validParamNames[paramName]; !valid {
			return "", parsley.NewError(paramNode.Pos(), fmt.Errorf("%q parameter does not exist", paramName))
		}
	}

	requiredParamNames := []variable.ID{}

	for _, paramName := range requiredParamNames {
		if _, set := node.ParamNodes()[paramName]; !set {
			return "", parsley.NewError(node.Pos(), fmt.Errorf("%s parameter is required", paramName))
		}
	}

	return "*BlockWithReference", nil
}

// CreateBlock creates a new BlockWithReference block
func (i BlockWithReferenceInterpreter) Eval(parentCtx interface{}, node basil.BlockNode) (basil.Block, parsley.Error) {
	block := &BlockWithReference{
		IDField: node.ID(),
	}

	ctx := block.Context(parentCtx)

	if err := i.EvalBlock(ctx, node, "default", block); err != nil {
		return nil, err
	}

	return block, nil
}

// EvalBlock evaluates all fields belonging to the given stage on a BlockWithReference block
func (i BlockWithReferenceInterpreter) EvalBlock(ctx interface{}, node basil.BlockNode, stage string, res basil.Block) parsley.Error {
	var err parsley.Error

	if preInterpreter, ok := res.(basil.BlockPreInterpreter); ok {
		if err = preInterpreter.PreEval(ctx, stage); err != nil {
			return err
		}
	}

	if postInterpreter, ok := res.(basil.BlockPostInterpreter); ok {
		if err = postInterpreter.PostEval(ctx, stage); err != nil {
			return err
		}
	}

	return nil
}

// HasForeignID returns true if the block ID is referencing an other block id
func (i BlockWithReferenceInterpreter) HasForeignID() bool {
	return true
}

// HasShortFormat returns true if the block can be defined in the short block format
func (i BlockWithReferenceInterpreter) ValueParamName() variable.ID {
	return ""
}

func (i BlockWithReferenceInterpreter) BlockRegistry() parsley.NodeTransformerRegistry {
	var block basil.Block = &BlockWithReference{}
	if b, ok := block.(basil.BlockRegistryAware); ok {
		return b.BlockRegistry()
	}

	return nil
}
