package block

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"reflect"
	"regexp"
	"strconv"
	"strings"
	"text/template"

	"github.com/opsidian/ocl/ocl"
	"github.com/opsidian/ocl/util"
)

var validTags = []string{
	"id",
	"name",
	"required",
	"stage",
	"ignore",
}

type Field struct {
	Name      string
	FieldName string
	Type      string
	TypeName  string
	Required  bool
	Stage     string
}

type FactoryTemplateParams struct {
	Package string
	Type    string
	Name    string
	Stages  []string
	Fields  []Field
}

const paramTemplate = `
		if valueNode, ok := s.paramNodes["{{.Name}}"]; ok {
			val, err := valueNode.Value(ctx)
			if err != nil {
				return err
			}
			if val, ok := val.({{.Type}}); ok {
				block.{{.FieldName}} = val
			} else {
				return parsley.NewError(valueNode.Pos(), errors.New("was expecting {{.TypeName}}"))
			}
		}{{ if .Required }} else {
			return parsley.NewError(s.typeNode.Pos(), errors.New("{{.Name}} parameter is required"))
		}{{ end }}
`

const factoryTemplate = `
// Code generated by ocl generate. DO NOT EDIT.
package {{.Package}}

import (
	"errors"

	"github.com/opsidian/ocl/ocl"
	"github.com/opsidian/parsley/parsley"
)

{{ $dot := .}}
func New{{$dot.Name}}Factory(
	typeNode parsley.Node,
	idNode parsley.Node,
	paramNodes map[string]parsley.Node,
	blockNodes []parsley.Node,
) (ocl.BlockFactory, parsley.Error) {
	return &{{.Name}}Factory{
		typeNode:   typeNode,
		id:         idNode,
		paramNodes: paramNodes,
		blockNodes: blockNodes,
	}, nil
}

type {{$dot.Name}}Factory struct {
	typeNode   parsley.Node
	id         parsley.Node
	paramNodes map[string]parsley.Node
	blockNodes []parsley.Node
}

func (s *{{$dot.Name}}Factory) CreateBlock(ctx interface{}) ocl.Block {
	return &{{$dot.Name}}{}
}

func (s *{{$dot.Name}}Factory) EvalBlock(ctx interface{}, stage string, res interface{}) parsley.Error {
	block, ok := res.(*{{$dot.Name}})
	if !ok {
		panic("result must be a type of *{{$dot.Name}}")
	}

	switch stage {
	{{range $stage := $dot.Stages -}}
	case "{{$stage}}":
		{{range $dot.Fields -}}
		{{ if eq .Stage $stage }}{{- template "block_param" . -}}{{ end }}
		{{- end -}}
	{{- end}}
	default:
		{{range $dot.Fields -}}
		{{ if eq .Stage "default" }}{{- template "block_param" . -}}{{ end }}
		{{- end}}
	}

	return nil
}
`

func GenerateFactory(dir string, name string, pkgName string) ([]byte, error) {
	params, err := generateTemplateParams(dir, name, pkgName)
	if err != nil {
		return nil, err
	}

	tmpl := template.Must(template.New("block_factory").Parse(factoryTemplate))
	paramTmpl := tmpl.New("block_param")
	paramTmpl = template.Must(paramTmpl.Parse(paramTemplate))

	res := &bytes.Buffer{}
	err = tmpl.Execute(res, params)
	if err != nil {
		return nil, err
	}

	formatted, err := format.Source(res.Bytes())
	if err != nil {
		return nil, err
	}

	return formatted, nil
}

func generateTemplateParams(dir string, name string, pkgName string) (*FactoryTemplateParams, error) {
	packages, err := loadPackages(dir)
	if err != nil {
		return nil, err
	}

	str, file, err := getStruct(packages[pkgName], name)
	if err != nil {
		return nil, err
	}

	fields, err := getFields(str, file)
	if err != nil {
		return nil, err
	}

	stages := []string{}
	for _, field := range fields {
		if field.Stage != "default" {
			if !util.StringSliceContains(stages, field.Stage) {
				stages = append(stages, field.Stage)
			}
		}
	}

	return &FactoryTemplateParams{
		Package: pkgName,
		Name:    name,
		Stages:  stages,
		Fields:  fields,
	}, nil
}

func loadPackages(dir string) (map[string]*ast.Package, error) {
	return parser.ParseDir(token.NewFileSet(), dir, nil, parser.AllErrors)
}

func getStruct(pkg *ast.Package, name string) (*ast.StructType, *ast.File, error) {
	var file *ast.File
	var str *ast.StructType
	var err error

	for _, f := range pkg.Files {
		ast.Inspect(f, func(node ast.Node) bool {
			typeSpec, ok := node.(*ast.TypeSpec)
			if !ok || typeSpec.Name.Name != name {
				return true
			}

			switch t := typeSpec.Type.(type) {
			case *ast.StructType:
				str = t
				file = f
				return true
			default:
				err = fmt.Errorf("'%s' does not refer to a struct", name)
			}

			return false
		})

		if str != nil {
			break
		}
	}

	return str, file, err
}

func getFields(str *ast.StructType, file *ast.File) ([]Field, error) {
	fields := make([]Field, 0, len(str.Fields.List))

	var idField string
	for _, field := range str.Fields.List {
		var tag string
		fieldName := field.Names[0].String()
		if field.Tag != nil {
			var err error
			tag, err = strconv.Unquote(field.Tag.Value)
			if err != nil {
				return nil, fmt.Errorf("tag is invalid for %s", fieldName)
			}
		}
		ftype, valid := getFieldType(field.Type)

		tags := util.ParseFieldTag(reflect.StructTag(tag), "ocl", fieldName)

		for _, key := range tags.Keys() {
			if !util.StringSliceContains(validTags, strings.ToLower(key)) {
				return nil, fmt.Errorf("invalid tag %s on %s", key, fieldName)
			}
		}

		if tags.GetBool("ignore") {
			continue
		}

		if !valid {
			return nil, fmt.Errorf("invalid field type: %s, use valid type or use ignore tag", fieldName)
		}

		if tags.GetBool("id") {
			if idField != "" {
				return nil, fmt.Errorf("multiple id fields were found: %s, %s", idField, fieldName)
			}
			idField = fieldName
		}

		name := tags.GetWithDefault("name", generateName(fieldName))
		if name == "" {
			return nil, fmt.Errorf("name can not be empty: %s", fieldName)
		}

		stage := tags.GetWithDefault("stage", "default")
		if stage == "" {
			return nil, fmt.Errorf("stage can not be empty: %s", fieldName)
		}

		typeName, _ := ocl.VariableTypes[ftype]

		fields = append(fields, Field{
			Name:      name,
			FieldName: fieldName,
			Required:  tags.GetBool("required"),
			Type:      ftype,
			TypeName:  typeName,
			Stage:     stage,
		})
	}

	if idField == "" {
		return nil, fmt.Errorf("id field is missing")
	}

	return fields, nil
}

func getFieldType(typeNode ast.Expr) (string, bool) {
	switch t := typeNode.(type) {
	case *ast.Ident:
		ftype := t.String()
		_, valid := ocl.VariableTypes[ftype]
		return ftype, valid
	default:
		b := &bytes.Buffer{}
		format.Node(b, token.NewFileSet(), t)
		_, valid := ocl.VariableTypes[b.String()]
		return b.String(), valid
	}

}

func generateName(str string) string {
	re := regexp.MustCompile("[A-Z][a-z0-9_]*")
	str = re.ReplaceAllStringFunc(str, func(str string) string {
		return "_" + strings.ToLower(str)
	})
	return strings.TrimLeft(str, "_")
}
