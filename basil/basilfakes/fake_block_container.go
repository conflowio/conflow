// Code generated by counterfeiter. DO NOT EDIT.
package basilfakes

import (
	"sync"

	"github.com/opsidian/basil/basil"
	"github.com/opsidian/parsley/parsley"
)

type FakeBlockContainer struct {
	CancelStub        func() bool
	cancelMutex       sync.RWMutex
	cancelArgsForCall []struct {
	}
	cancelReturns struct {
		result1 bool
	}
	cancelReturnsOnCall map[int]struct {
		result1 bool
	}
	CloseStub        func()
	closeMutex       sync.RWMutex
	closeArgsForCall []struct {
	}
	JobIDStub        func() int
	jobIDMutex       sync.RWMutex
	jobIDArgsForCall []struct {
	}
	jobIDReturns struct {
		result1 int
	}
	jobIDReturnsOnCall map[int]struct {
		result1 int
	}
	JobNameStub        func() basil.ID
	jobNameMutex       sync.RWMutex
	jobNameArgsForCall []struct {
	}
	jobNameReturns struct {
		result1 basil.ID
	}
	jobNameReturnsOnCall map[int]struct {
		result1 basil.ID
	}
	LightweightStub        func() bool
	lightweightMutex       sync.RWMutex
	lightweightArgsForCall []struct {
	}
	lightweightReturns struct {
		result1 bool
	}
	lightweightReturnsOnCall map[int]struct {
		result1 bool
	}
	NodeStub        func() basil.Node
	nodeMutex       sync.RWMutex
	nodeArgsForCall []struct {
	}
	nodeReturns struct {
		result1 basil.Node
	}
	nodeReturnsOnCall map[int]struct {
		result1 basil.Node
	}
	ParamStub        func(basil.ID) interface{}
	paramMutex       sync.RWMutex
	paramArgsForCall []struct {
		arg1 basil.ID
	}
	paramReturns struct {
		result1 interface{}
	}
	paramReturnsOnCall map[int]struct {
		result1 interface{}
	}
	PublishBlockStub        func(basil.Block) error
	publishBlockMutex       sync.RWMutex
	publishBlockArgsForCall []struct {
		arg1 basil.Block
	}
	publishBlockReturns struct {
		result1 error
	}
	publishBlockReturnsOnCall map[int]struct {
		result1 error
	}
	RunStub        func()
	runMutex       sync.RWMutex
	runArgsForCall []struct {
	}
	ScheduleChildStub        func(basil.Container, bool) bool
	scheduleChildMutex       sync.RWMutex
	scheduleChildArgsForCall []struct {
		arg1 basil.Container
		arg2 bool
	}
	scheduleChildReturns struct {
		result1 bool
	}
	scheduleChildReturnsOnCall map[int]struct {
		result1 bool
	}
	SetChildStub        func(basil.Container)
	setChildMutex       sync.RWMutex
	setChildArgsForCall []struct {
		arg1 basil.Container
	}
	SetErrorStub        func(parsley.Error)
	setErrorMutex       sync.RWMutex
	setErrorArgsForCall []struct {
		arg1 parsley.Error
	}
	SetJobIDStub        func(int)
	setJobIDMutex       sync.RWMutex
	setJobIDArgsForCall []struct {
		arg1 int
	}
	ValueStub        func() (interface{}, parsley.Error)
	valueMutex       sync.RWMutex
	valueArgsForCall []struct {
	}
	valueReturns struct {
		result1 interface{}
		result2 parsley.Error
	}
	valueReturnsOnCall map[int]struct {
		result1 interface{}
		result2 parsley.Error
	}
	WaitGroupsStub        func() []basil.WaitGroup
	waitGroupsMutex       sync.RWMutex
	waitGroupsArgsForCall []struct {
	}
	waitGroupsReturns struct {
		result1 []basil.WaitGroup
	}
	waitGroupsReturnsOnCall map[int]struct {
		result1 []basil.WaitGroup
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeBlockContainer) Cancel() bool {
	fake.cancelMutex.Lock()
	ret, specificReturn := fake.cancelReturnsOnCall[len(fake.cancelArgsForCall)]
	fake.cancelArgsForCall = append(fake.cancelArgsForCall, struct {
	}{})
	fake.recordInvocation("Cancel", []interface{}{})
	fake.cancelMutex.Unlock()
	if fake.CancelStub != nil {
		return fake.CancelStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.cancelReturns
	return fakeReturns.result1
}

func (fake *FakeBlockContainer) CancelCallCount() int {
	fake.cancelMutex.RLock()
	defer fake.cancelMutex.RUnlock()
	return len(fake.cancelArgsForCall)
}

func (fake *FakeBlockContainer) CancelCalls(stub func() bool) {
	fake.cancelMutex.Lock()
	defer fake.cancelMutex.Unlock()
	fake.CancelStub = stub
}

func (fake *FakeBlockContainer) CancelReturns(result1 bool) {
	fake.cancelMutex.Lock()
	defer fake.cancelMutex.Unlock()
	fake.CancelStub = nil
	fake.cancelReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeBlockContainer) CancelReturnsOnCall(i int, result1 bool) {
	fake.cancelMutex.Lock()
	defer fake.cancelMutex.Unlock()
	fake.CancelStub = nil
	if fake.cancelReturnsOnCall == nil {
		fake.cancelReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.cancelReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeBlockContainer) Close() {
	fake.closeMutex.Lock()
	fake.closeArgsForCall = append(fake.closeArgsForCall, struct {
	}{})
	fake.recordInvocation("Close", []interface{}{})
	fake.closeMutex.Unlock()
	if fake.CloseStub != nil {
		fake.CloseStub()
	}
}

func (fake *FakeBlockContainer) CloseCallCount() int {
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	return len(fake.closeArgsForCall)
}

func (fake *FakeBlockContainer) CloseCalls(stub func()) {
	fake.closeMutex.Lock()
	defer fake.closeMutex.Unlock()
	fake.CloseStub = stub
}

func (fake *FakeBlockContainer) JobID() int {
	fake.jobIDMutex.Lock()
	ret, specificReturn := fake.jobIDReturnsOnCall[len(fake.jobIDArgsForCall)]
	fake.jobIDArgsForCall = append(fake.jobIDArgsForCall, struct {
	}{})
	fake.recordInvocation("JobID", []interface{}{})
	fake.jobIDMutex.Unlock()
	if fake.JobIDStub != nil {
		return fake.JobIDStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.jobIDReturns
	return fakeReturns.result1
}

func (fake *FakeBlockContainer) JobIDCallCount() int {
	fake.jobIDMutex.RLock()
	defer fake.jobIDMutex.RUnlock()
	return len(fake.jobIDArgsForCall)
}

func (fake *FakeBlockContainer) JobIDCalls(stub func() int) {
	fake.jobIDMutex.Lock()
	defer fake.jobIDMutex.Unlock()
	fake.JobIDStub = stub
}

func (fake *FakeBlockContainer) JobIDReturns(result1 int) {
	fake.jobIDMutex.Lock()
	defer fake.jobIDMutex.Unlock()
	fake.JobIDStub = nil
	fake.jobIDReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeBlockContainer) JobIDReturnsOnCall(i int, result1 int) {
	fake.jobIDMutex.Lock()
	defer fake.jobIDMutex.Unlock()
	fake.JobIDStub = nil
	if fake.jobIDReturnsOnCall == nil {
		fake.jobIDReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.jobIDReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeBlockContainer) JobName() basil.ID {
	fake.jobNameMutex.Lock()
	ret, specificReturn := fake.jobNameReturnsOnCall[len(fake.jobNameArgsForCall)]
	fake.jobNameArgsForCall = append(fake.jobNameArgsForCall, struct {
	}{})
	fake.recordInvocation("JobName", []interface{}{})
	fake.jobNameMutex.Unlock()
	if fake.JobNameStub != nil {
		return fake.JobNameStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.jobNameReturns
	return fakeReturns.result1
}

func (fake *FakeBlockContainer) JobNameCallCount() int {
	fake.jobNameMutex.RLock()
	defer fake.jobNameMutex.RUnlock()
	return len(fake.jobNameArgsForCall)
}

func (fake *FakeBlockContainer) JobNameCalls(stub func() basil.ID) {
	fake.jobNameMutex.Lock()
	defer fake.jobNameMutex.Unlock()
	fake.JobNameStub = stub
}

func (fake *FakeBlockContainer) JobNameReturns(result1 basil.ID) {
	fake.jobNameMutex.Lock()
	defer fake.jobNameMutex.Unlock()
	fake.JobNameStub = nil
	fake.jobNameReturns = struct {
		result1 basil.ID
	}{result1}
}

func (fake *FakeBlockContainer) JobNameReturnsOnCall(i int, result1 basil.ID) {
	fake.jobNameMutex.Lock()
	defer fake.jobNameMutex.Unlock()
	fake.JobNameStub = nil
	if fake.jobNameReturnsOnCall == nil {
		fake.jobNameReturnsOnCall = make(map[int]struct {
			result1 basil.ID
		})
	}
	fake.jobNameReturnsOnCall[i] = struct {
		result1 basil.ID
	}{result1}
}

func (fake *FakeBlockContainer) Lightweight() bool {
	fake.lightweightMutex.Lock()
	ret, specificReturn := fake.lightweightReturnsOnCall[len(fake.lightweightArgsForCall)]
	fake.lightweightArgsForCall = append(fake.lightweightArgsForCall, struct {
	}{})
	fake.recordInvocation("Lightweight", []interface{}{})
	fake.lightweightMutex.Unlock()
	if fake.LightweightStub != nil {
		return fake.LightweightStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.lightweightReturns
	return fakeReturns.result1
}

func (fake *FakeBlockContainer) LightweightCallCount() int {
	fake.lightweightMutex.RLock()
	defer fake.lightweightMutex.RUnlock()
	return len(fake.lightweightArgsForCall)
}

func (fake *FakeBlockContainer) LightweightCalls(stub func() bool) {
	fake.lightweightMutex.Lock()
	defer fake.lightweightMutex.Unlock()
	fake.LightweightStub = stub
}

func (fake *FakeBlockContainer) LightweightReturns(result1 bool) {
	fake.lightweightMutex.Lock()
	defer fake.lightweightMutex.Unlock()
	fake.LightweightStub = nil
	fake.lightweightReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeBlockContainer) LightweightReturnsOnCall(i int, result1 bool) {
	fake.lightweightMutex.Lock()
	defer fake.lightweightMutex.Unlock()
	fake.LightweightStub = nil
	if fake.lightweightReturnsOnCall == nil {
		fake.lightweightReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.lightweightReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeBlockContainer) Node() basil.Node {
	fake.nodeMutex.Lock()
	ret, specificReturn := fake.nodeReturnsOnCall[len(fake.nodeArgsForCall)]
	fake.nodeArgsForCall = append(fake.nodeArgsForCall, struct {
	}{})
	fake.recordInvocation("Node", []interface{}{})
	fake.nodeMutex.Unlock()
	if fake.NodeStub != nil {
		return fake.NodeStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.nodeReturns
	return fakeReturns.result1
}

func (fake *FakeBlockContainer) NodeCallCount() int {
	fake.nodeMutex.RLock()
	defer fake.nodeMutex.RUnlock()
	return len(fake.nodeArgsForCall)
}

func (fake *FakeBlockContainer) NodeCalls(stub func() basil.Node) {
	fake.nodeMutex.Lock()
	defer fake.nodeMutex.Unlock()
	fake.NodeStub = stub
}

func (fake *FakeBlockContainer) NodeReturns(result1 basil.Node) {
	fake.nodeMutex.Lock()
	defer fake.nodeMutex.Unlock()
	fake.NodeStub = nil
	fake.nodeReturns = struct {
		result1 basil.Node
	}{result1}
}

func (fake *FakeBlockContainer) NodeReturnsOnCall(i int, result1 basil.Node) {
	fake.nodeMutex.Lock()
	defer fake.nodeMutex.Unlock()
	fake.NodeStub = nil
	if fake.nodeReturnsOnCall == nil {
		fake.nodeReturnsOnCall = make(map[int]struct {
			result1 basil.Node
		})
	}
	fake.nodeReturnsOnCall[i] = struct {
		result1 basil.Node
	}{result1}
}

func (fake *FakeBlockContainer) Param(arg1 basil.ID) interface{} {
	fake.paramMutex.Lock()
	ret, specificReturn := fake.paramReturnsOnCall[len(fake.paramArgsForCall)]
	fake.paramArgsForCall = append(fake.paramArgsForCall, struct {
		arg1 basil.ID
	}{arg1})
	fake.recordInvocation("Param", []interface{}{arg1})
	fake.paramMutex.Unlock()
	if fake.ParamStub != nil {
		return fake.ParamStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.paramReturns
	return fakeReturns.result1
}

func (fake *FakeBlockContainer) ParamCallCount() int {
	fake.paramMutex.RLock()
	defer fake.paramMutex.RUnlock()
	return len(fake.paramArgsForCall)
}

func (fake *FakeBlockContainer) ParamCalls(stub func(basil.ID) interface{}) {
	fake.paramMutex.Lock()
	defer fake.paramMutex.Unlock()
	fake.ParamStub = stub
}

func (fake *FakeBlockContainer) ParamArgsForCall(i int) basil.ID {
	fake.paramMutex.RLock()
	defer fake.paramMutex.RUnlock()
	argsForCall := fake.paramArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeBlockContainer) ParamReturns(result1 interface{}) {
	fake.paramMutex.Lock()
	defer fake.paramMutex.Unlock()
	fake.ParamStub = nil
	fake.paramReturns = struct {
		result1 interface{}
	}{result1}
}

func (fake *FakeBlockContainer) ParamReturnsOnCall(i int, result1 interface{}) {
	fake.paramMutex.Lock()
	defer fake.paramMutex.Unlock()
	fake.ParamStub = nil
	if fake.paramReturnsOnCall == nil {
		fake.paramReturnsOnCall = make(map[int]struct {
			result1 interface{}
		})
	}
	fake.paramReturnsOnCall[i] = struct {
		result1 interface{}
	}{result1}
}

func (fake *FakeBlockContainer) PublishBlock(arg1 basil.Block) error {
	fake.publishBlockMutex.Lock()
	ret, specificReturn := fake.publishBlockReturnsOnCall[len(fake.publishBlockArgsForCall)]
	fake.publishBlockArgsForCall = append(fake.publishBlockArgsForCall, struct {
		arg1 basil.Block
	}{arg1})
	fake.recordInvocation("PublishBlock", []interface{}{arg1})
	fake.publishBlockMutex.Unlock()
	if fake.PublishBlockStub != nil {
		return fake.PublishBlockStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.publishBlockReturns
	return fakeReturns.result1
}

func (fake *FakeBlockContainer) PublishBlockCallCount() int {
	fake.publishBlockMutex.RLock()
	defer fake.publishBlockMutex.RUnlock()
	return len(fake.publishBlockArgsForCall)
}

func (fake *FakeBlockContainer) PublishBlockCalls(stub func(basil.Block) error) {
	fake.publishBlockMutex.Lock()
	defer fake.publishBlockMutex.Unlock()
	fake.PublishBlockStub = stub
}

func (fake *FakeBlockContainer) PublishBlockArgsForCall(i int) basil.Block {
	fake.publishBlockMutex.RLock()
	defer fake.publishBlockMutex.RUnlock()
	argsForCall := fake.publishBlockArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeBlockContainer) PublishBlockReturns(result1 error) {
	fake.publishBlockMutex.Lock()
	defer fake.publishBlockMutex.Unlock()
	fake.PublishBlockStub = nil
	fake.publishBlockReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeBlockContainer) PublishBlockReturnsOnCall(i int, result1 error) {
	fake.publishBlockMutex.Lock()
	defer fake.publishBlockMutex.Unlock()
	fake.PublishBlockStub = nil
	if fake.publishBlockReturnsOnCall == nil {
		fake.publishBlockReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.publishBlockReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeBlockContainer) Run() {
	fake.runMutex.Lock()
	fake.runArgsForCall = append(fake.runArgsForCall, struct {
	}{})
	fake.recordInvocation("Run", []interface{}{})
	fake.runMutex.Unlock()
	if fake.RunStub != nil {
		fake.RunStub()
	}
}

func (fake *FakeBlockContainer) RunCallCount() int {
	fake.runMutex.RLock()
	defer fake.runMutex.RUnlock()
	return len(fake.runArgsForCall)
}

func (fake *FakeBlockContainer) RunCalls(stub func()) {
	fake.runMutex.Lock()
	defer fake.runMutex.Unlock()
	fake.RunStub = stub
}

func (fake *FakeBlockContainer) ScheduleChild(arg1 basil.Container, arg2 bool) bool {
	fake.scheduleChildMutex.Lock()
	ret, specificReturn := fake.scheduleChildReturnsOnCall[len(fake.scheduleChildArgsForCall)]
	fake.scheduleChildArgsForCall = append(fake.scheduleChildArgsForCall, struct {
		arg1 basil.Container
		arg2 bool
	}{arg1, arg2})
	fake.recordInvocation("ScheduleChild", []interface{}{arg1, arg2})
	fake.scheduleChildMutex.Unlock()
	if fake.ScheduleChildStub != nil {
		return fake.ScheduleChildStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.scheduleChildReturns
	return fakeReturns.result1
}

func (fake *FakeBlockContainer) ScheduleChildCallCount() int {
	fake.scheduleChildMutex.RLock()
	defer fake.scheduleChildMutex.RUnlock()
	return len(fake.scheduleChildArgsForCall)
}

func (fake *FakeBlockContainer) ScheduleChildCalls(stub func(basil.Container, bool) bool) {
	fake.scheduleChildMutex.Lock()
	defer fake.scheduleChildMutex.Unlock()
	fake.ScheduleChildStub = stub
}

func (fake *FakeBlockContainer) ScheduleChildArgsForCall(i int) (basil.Container, bool) {
	fake.scheduleChildMutex.RLock()
	defer fake.scheduleChildMutex.RUnlock()
	argsForCall := fake.scheduleChildArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeBlockContainer) ScheduleChildReturns(result1 bool) {
	fake.scheduleChildMutex.Lock()
	defer fake.scheduleChildMutex.Unlock()
	fake.ScheduleChildStub = nil
	fake.scheduleChildReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeBlockContainer) ScheduleChildReturnsOnCall(i int, result1 bool) {
	fake.scheduleChildMutex.Lock()
	defer fake.scheduleChildMutex.Unlock()
	fake.ScheduleChildStub = nil
	if fake.scheduleChildReturnsOnCall == nil {
		fake.scheduleChildReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.scheduleChildReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeBlockContainer) SetChild(arg1 basil.Container) {
	fake.setChildMutex.Lock()
	fake.setChildArgsForCall = append(fake.setChildArgsForCall, struct {
		arg1 basil.Container
	}{arg1})
	fake.recordInvocation("SetChild", []interface{}{arg1})
	fake.setChildMutex.Unlock()
	if fake.SetChildStub != nil {
		fake.SetChildStub(arg1)
	}
}

func (fake *FakeBlockContainer) SetChildCallCount() int {
	fake.setChildMutex.RLock()
	defer fake.setChildMutex.RUnlock()
	return len(fake.setChildArgsForCall)
}

func (fake *FakeBlockContainer) SetChildCalls(stub func(basil.Container)) {
	fake.setChildMutex.Lock()
	defer fake.setChildMutex.Unlock()
	fake.SetChildStub = stub
}

func (fake *FakeBlockContainer) SetChildArgsForCall(i int) basil.Container {
	fake.setChildMutex.RLock()
	defer fake.setChildMutex.RUnlock()
	argsForCall := fake.setChildArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeBlockContainer) SetError(arg1 parsley.Error) {
	fake.setErrorMutex.Lock()
	fake.setErrorArgsForCall = append(fake.setErrorArgsForCall, struct {
		arg1 parsley.Error
	}{arg1})
	fake.recordInvocation("SetError", []interface{}{arg1})
	fake.setErrorMutex.Unlock()
	if fake.SetErrorStub != nil {
		fake.SetErrorStub(arg1)
	}
}

func (fake *FakeBlockContainer) SetErrorCallCount() int {
	fake.setErrorMutex.RLock()
	defer fake.setErrorMutex.RUnlock()
	return len(fake.setErrorArgsForCall)
}

func (fake *FakeBlockContainer) SetErrorCalls(stub func(parsley.Error)) {
	fake.setErrorMutex.Lock()
	defer fake.setErrorMutex.Unlock()
	fake.SetErrorStub = stub
}

func (fake *FakeBlockContainer) SetErrorArgsForCall(i int) parsley.Error {
	fake.setErrorMutex.RLock()
	defer fake.setErrorMutex.RUnlock()
	argsForCall := fake.setErrorArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeBlockContainer) SetJobID(arg1 int) {
	fake.setJobIDMutex.Lock()
	fake.setJobIDArgsForCall = append(fake.setJobIDArgsForCall, struct {
		arg1 int
	}{arg1})
	fake.recordInvocation("SetJobID", []interface{}{arg1})
	fake.setJobIDMutex.Unlock()
	if fake.SetJobIDStub != nil {
		fake.SetJobIDStub(arg1)
	}
}

func (fake *FakeBlockContainer) SetJobIDCallCount() int {
	fake.setJobIDMutex.RLock()
	defer fake.setJobIDMutex.RUnlock()
	return len(fake.setJobIDArgsForCall)
}

func (fake *FakeBlockContainer) SetJobIDCalls(stub func(int)) {
	fake.setJobIDMutex.Lock()
	defer fake.setJobIDMutex.Unlock()
	fake.SetJobIDStub = stub
}

func (fake *FakeBlockContainer) SetJobIDArgsForCall(i int) int {
	fake.setJobIDMutex.RLock()
	defer fake.setJobIDMutex.RUnlock()
	argsForCall := fake.setJobIDArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeBlockContainer) Value() (interface{}, parsley.Error) {
	fake.valueMutex.Lock()
	ret, specificReturn := fake.valueReturnsOnCall[len(fake.valueArgsForCall)]
	fake.valueArgsForCall = append(fake.valueArgsForCall, struct {
	}{})
	fake.recordInvocation("Value", []interface{}{})
	fake.valueMutex.Unlock()
	if fake.ValueStub != nil {
		return fake.ValueStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.valueReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeBlockContainer) ValueCallCount() int {
	fake.valueMutex.RLock()
	defer fake.valueMutex.RUnlock()
	return len(fake.valueArgsForCall)
}

func (fake *FakeBlockContainer) ValueCalls(stub func() (interface{}, parsley.Error)) {
	fake.valueMutex.Lock()
	defer fake.valueMutex.Unlock()
	fake.ValueStub = stub
}

func (fake *FakeBlockContainer) ValueReturns(result1 interface{}, result2 parsley.Error) {
	fake.valueMutex.Lock()
	defer fake.valueMutex.Unlock()
	fake.ValueStub = nil
	fake.valueReturns = struct {
		result1 interface{}
		result2 parsley.Error
	}{result1, result2}
}

func (fake *FakeBlockContainer) ValueReturnsOnCall(i int, result1 interface{}, result2 parsley.Error) {
	fake.valueMutex.Lock()
	defer fake.valueMutex.Unlock()
	fake.ValueStub = nil
	if fake.valueReturnsOnCall == nil {
		fake.valueReturnsOnCall = make(map[int]struct {
			result1 interface{}
			result2 parsley.Error
		})
	}
	fake.valueReturnsOnCall[i] = struct {
		result1 interface{}
		result2 parsley.Error
	}{result1, result2}
}

func (fake *FakeBlockContainer) WaitGroups() []basil.WaitGroup {
	fake.waitGroupsMutex.Lock()
	ret, specificReturn := fake.waitGroupsReturnsOnCall[len(fake.waitGroupsArgsForCall)]
	fake.waitGroupsArgsForCall = append(fake.waitGroupsArgsForCall, struct {
	}{})
	fake.recordInvocation("WaitGroups", []interface{}{})
	fake.waitGroupsMutex.Unlock()
	if fake.WaitGroupsStub != nil {
		return fake.WaitGroupsStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.waitGroupsReturns
	return fakeReturns.result1
}

func (fake *FakeBlockContainer) WaitGroupsCallCount() int {
	fake.waitGroupsMutex.RLock()
	defer fake.waitGroupsMutex.RUnlock()
	return len(fake.waitGroupsArgsForCall)
}

func (fake *FakeBlockContainer) WaitGroupsCalls(stub func() []basil.WaitGroup) {
	fake.waitGroupsMutex.Lock()
	defer fake.waitGroupsMutex.Unlock()
	fake.WaitGroupsStub = stub
}

func (fake *FakeBlockContainer) WaitGroupsReturns(result1 []basil.WaitGroup) {
	fake.waitGroupsMutex.Lock()
	defer fake.waitGroupsMutex.Unlock()
	fake.WaitGroupsStub = nil
	fake.waitGroupsReturns = struct {
		result1 []basil.WaitGroup
	}{result1}
}

func (fake *FakeBlockContainer) WaitGroupsReturnsOnCall(i int, result1 []basil.WaitGroup) {
	fake.waitGroupsMutex.Lock()
	defer fake.waitGroupsMutex.Unlock()
	fake.WaitGroupsStub = nil
	if fake.waitGroupsReturnsOnCall == nil {
		fake.waitGroupsReturnsOnCall = make(map[int]struct {
			result1 []basil.WaitGroup
		})
	}
	fake.waitGroupsReturnsOnCall[i] = struct {
		result1 []basil.WaitGroup
	}{result1}
}

func (fake *FakeBlockContainer) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.cancelMutex.RLock()
	defer fake.cancelMutex.RUnlock()
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	fake.jobIDMutex.RLock()
	defer fake.jobIDMutex.RUnlock()
	fake.jobNameMutex.RLock()
	defer fake.jobNameMutex.RUnlock()
	fake.lightweightMutex.RLock()
	defer fake.lightweightMutex.RUnlock()
	fake.nodeMutex.RLock()
	defer fake.nodeMutex.RUnlock()
	fake.paramMutex.RLock()
	defer fake.paramMutex.RUnlock()
	fake.publishBlockMutex.RLock()
	defer fake.publishBlockMutex.RUnlock()
	fake.runMutex.RLock()
	defer fake.runMutex.RUnlock()
	fake.scheduleChildMutex.RLock()
	defer fake.scheduleChildMutex.RUnlock()
	fake.setChildMutex.RLock()
	defer fake.setChildMutex.RUnlock()
	fake.setErrorMutex.RLock()
	defer fake.setErrorMutex.RUnlock()
	fake.setJobIDMutex.RLock()
	defer fake.setJobIDMutex.RUnlock()
	fake.valueMutex.RLock()
	defer fake.valueMutex.RUnlock()
	fake.waitGroupsMutex.RLock()
	defer fake.waitGroupsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeBlockContainer) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ basil.BlockContainer = new(FakeBlockContainer)
