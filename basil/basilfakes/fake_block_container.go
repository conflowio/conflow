// Code generated by counterfeiter. DO NOT EDIT.
package basilfakes

import (
	"sync"
	"time"

	"github.com/opsidian/basil/basil"
	"github.com/opsidian/basil/util"
	"github.com/opsidian/parsley/parsley"
)

type FakeBlockContainer struct {
	BlockStub        func() basil.Block
	blockMutex       sync.RWMutex
	blockArgsForCall []struct {
	}
	blockReturns struct {
		result1 basil.Block
	}
	blockReturnsOnCall map[int]struct {
		result1 basil.Block
	}
	CancelStub        func() bool
	cancelMutex       sync.RWMutex
	cancelArgsForCall []struct {
	}
	cancelReturns struct {
		result1 bool
	}
	cancelReturnsOnCall map[int]struct {
		result1 bool
	}
	CloseStub        func()
	closeMutex       sync.RWMutex
	closeArgsForCall []struct {
	}
	EvaluateChildStub        func(*basil.NodeContainer, basil.ID) bool
	evaluateChildMutex       sync.RWMutex
	evaluateChildArgsForCall []struct {
		arg1 *basil.NodeContainer
		arg2 basil.ID
	}
	evaluateChildReturns struct {
		result1 bool
	}
	evaluateChildReturnsOnCall map[int]struct {
		result1 bool
	}
	IDStub        func() basil.ID
	iDMutex       sync.RWMutex
	iDArgsForCall []struct {
	}
	iDReturns struct {
		result1 basil.ID
	}
	iDReturnsOnCall map[int]struct {
		result1 basil.ID
	}
	JobIDStub        func() basil.ID
	jobIDMutex       sync.RWMutex
	jobIDArgsForCall []struct {
	}
	jobIDReturns struct {
		result1 basil.ID
	}
	jobIDReturnsOnCall map[int]struct {
		result1 basil.ID
	}
	LightweightStub        func() bool
	lightweightMutex       sync.RWMutex
	lightweightArgsForCall []struct {
	}
	lightweightReturns struct {
		result1 bool
	}
	lightweightReturnsOnCall map[int]struct {
		result1 bool
	}
	NodeStub        func() basil.Node
	nodeMutex       sync.RWMutex
	nodeArgsForCall []struct {
	}
	nodeReturns struct {
		result1 basil.Node
	}
	nodeReturnsOnCall map[int]struct {
		result1 basil.Node
	}
	ParamStub        func(basil.ID) interface{}
	paramMutex       sync.RWMutex
	paramArgsForCall []struct {
		arg1 basil.ID
	}
	paramReturns struct {
		result1 interface{}
	}
	paramReturnsOnCall map[int]struct {
		result1 interface{}
	}
	PublishBlockStub        func(basil.Block) error
	publishBlockMutex       sync.RWMutex
	publishBlockArgsForCall []struct {
		arg1 basil.Block
	}
	publishBlockReturns struct {
		result1 error
	}
	publishBlockReturnsOnCall map[int]struct {
		result1 error
	}
	RunStub        func()
	runMutex       sync.RWMutex
	runArgsForCall []struct {
	}
	SetChildStub        func(basil.Container)
	setChildMutex       sync.RWMutex
	setChildArgsForCall []struct {
		arg1 basil.Container
	}
	SetRetryStub        func(basil.Retryable)
	setRetryMutex       sync.RWMutex
	setRetryArgsForCall []struct {
		arg1 basil.Retryable
	}
	SetTimeoutStub        func(time.Duration)
	setTimeoutMutex       sync.RWMutex
	setTimeoutArgsForCall []struct {
		arg1 time.Duration
	}
	SkipStub        func()
	skipMutex       sync.RWMutex
	skipArgsForCall []struct {
	}
	TriggerStub        func() basil.ID
	triggerMutex       sync.RWMutex
	triggerArgsForCall []struct {
	}
	triggerReturns struct {
		result1 basil.ID
	}
	triggerReturnsOnCall map[int]struct {
		result1 basil.ID
	}
	ValueStub        func() (interface{}, parsley.Error)
	valueMutex       sync.RWMutex
	valueArgsForCall []struct {
	}
	valueReturns struct {
		result1 interface{}
		result2 parsley.Error
	}
	valueReturnsOnCall map[int]struct {
		result1 interface{}
		result2 parsley.Error
	}
	WaitGroupsStub        func() []*util.WaitGroup
	waitGroupsMutex       sync.RWMutex
	waitGroupsArgsForCall []struct {
	}
	waitGroupsReturns struct {
		result1 []*util.WaitGroup
	}
	waitGroupsReturnsOnCall map[int]struct {
		result1 []*util.WaitGroup
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeBlockContainer) Block() basil.Block {
	fake.blockMutex.Lock()
	ret, specificReturn := fake.blockReturnsOnCall[len(fake.blockArgsForCall)]
	fake.blockArgsForCall = append(fake.blockArgsForCall, struct {
	}{})
	fake.recordInvocation("Block", []interface{}{})
	fake.blockMutex.Unlock()
	if fake.BlockStub != nil {
		return fake.BlockStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.blockReturns
	return fakeReturns.result1
}

func (fake *FakeBlockContainer) BlockCallCount() int {
	fake.blockMutex.RLock()
	defer fake.blockMutex.RUnlock()
	return len(fake.blockArgsForCall)
}

func (fake *FakeBlockContainer) BlockCalls(stub func() basil.Block) {
	fake.blockMutex.Lock()
	defer fake.blockMutex.Unlock()
	fake.BlockStub = stub
}

func (fake *FakeBlockContainer) BlockReturns(result1 basil.Block) {
	fake.blockMutex.Lock()
	defer fake.blockMutex.Unlock()
	fake.BlockStub = nil
	fake.blockReturns = struct {
		result1 basil.Block
	}{result1}
}

func (fake *FakeBlockContainer) BlockReturnsOnCall(i int, result1 basil.Block) {
	fake.blockMutex.Lock()
	defer fake.blockMutex.Unlock()
	fake.BlockStub = nil
	if fake.blockReturnsOnCall == nil {
		fake.blockReturnsOnCall = make(map[int]struct {
			result1 basil.Block
		})
	}
	fake.blockReturnsOnCall[i] = struct {
		result1 basil.Block
	}{result1}
}

func (fake *FakeBlockContainer) Cancel() bool {
	fake.cancelMutex.Lock()
	ret, specificReturn := fake.cancelReturnsOnCall[len(fake.cancelArgsForCall)]
	fake.cancelArgsForCall = append(fake.cancelArgsForCall, struct {
	}{})
	fake.recordInvocation("Cancel", []interface{}{})
	fake.cancelMutex.Unlock()
	if fake.CancelStub != nil {
		return fake.CancelStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.cancelReturns
	return fakeReturns.result1
}

func (fake *FakeBlockContainer) CancelCallCount() int {
	fake.cancelMutex.RLock()
	defer fake.cancelMutex.RUnlock()
	return len(fake.cancelArgsForCall)
}

func (fake *FakeBlockContainer) CancelCalls(stub func() bool) {
	fake.cancelMutex.Lock()
	defer fake.cancelMutex.Unlock()
	fake.CancelStub = stub
}

func (fake *FakeBlockContainer) CancelReturns(result1 bool) {
	fake.cancelMutex.Lock()
	defer fake.cancelMutex.Unlock()
	fake.CancelStub = nil
	fake.cancelReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeBlockContainer) CancelReturnsOnCall(i int, result1 bool) {
	fake.cancelMutex.Lock()
	defer fake.cancelMutex.Unlock()
	fake.CancelStub = nil
	if fake.cancelReturnsOnCall == nil {
		fake.cancelReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.cancelReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeBlockContainer) Close() {
	fake.closeMutex.Lock()
	fake.closeArgsForCall = append(fake.closeArgsForCall, struct {
	}{})
	fake.recordInvocation("Close", []interface{}{})
	fake.closeMutex.Unlock()
	if fake.CloseStub != nil {
		fake.CloseStub()
	}
}

func (fake *FakeBlockContainer) CloseCallCount() int {
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	return len(fake.closeArgsForCall)
}

func (fake *FakeBlockContainer) CloseCalls(stub func()) {
	fake.closeMutex.Lock()
	defer fake.closeMutex.Unlock()
	fake.CloseStub = stub
}

func (fake *FakeBlockContainer) EvaluateChild(arg1 *basil.NodeContainer, arg2 basil.ID) bool {
	fake.evaluateChildMutex.Lock()
	ret, specificReturn := fake.evaluateChildReturnsOnCall[len(fake.evaluateChildArgsForCall)]
	fake.evaluateChildArgsForCall = append(fake.evaluateChildArgsForCall, struct {
		arg1 *basil.NodeContainer
		arg2 basil.ID
	}{arg1, arg2})
	fake.recordInvocation("EvaluateChild", []interface{}{arg1, arg2})
	fake.evaluateChildMutex.Unlock()
	if fake.EvaluateChildStub != nil {
		return fake.EvaluateChildStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.evaluateChildReturns
	return fakeReturns.result1
}

func (fake *FakeBlockContainer) EvaluateChildCallCount() int {
	fake.evaluateChildMutex.RLock()
	defer fake.evaluateChildMutex.RUnlock()
	return len(fake.evaluateChildArgsForCall)
}

func (fake *FakeBlockContainer) EvaluateChildCalls(stub func(*basil.NodeContainer, basil.ID) bool) {
	fake.evaluateChildMutex.Lock()
	defer fake.evaluateChildMutex.Unlock()
	fake.EvaluateChildStub = stub
}

func (fake *FakeBlockContainer) EvaluateChildArgsForCall(i int) (*basil.NodeContainer, basil.ID) {
	fake.evaluateChildMutex.RLock()
	defer fake.evaluateChildMutex.RUnlock()
	argsForCall := fake.evaluateChildArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeBlockContainer) EvaluateChildReturns(result1 bool) {
	fake.evaluateChildMutex.Lock()
	defer fake.evaluateChildMutex.Unlock()
	fake.EvaluateChildStub = nil
	fake.evaluateChildReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeBlockContainer) EvaluateChildReturnsOnCall(i int, result1 bool) {
	fake.evaluateChildMutex.Lock()
	defer fake.evaluateChildMutex.Unlock()
	fake.EvaluateChildStub = nil
	if fake.evaluateChildReturnsOnCall == nil {
		fake.evaluateChildReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.evaluateChildReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeBlockContainer) ID() basil.ID {
	fake.iDMutex.Lock()
	ret, specificReturn := fake.iDReturnsOnCall[len(fake.iDArgsForCall)]
	fake.iDArgsForCall = append(fake.iDArgsForCall, struct {
	}{})
	fake.recordInvocation("ID", []interface{}{})
	fake.iDMutex.Unlock()
	if fake.IDStub != nil {
		return fake.IDStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.iDReturns
	return fakeReturns.result1
}

func (fake *FakeBlockContainer) IDCallCount() int {
	fake.iDMutex.RLock()
	defer fake.iDMutex.RUnlock()
	return len(fake.iDArgsForCall)
}

func (fake *FakeBlockContainer) IDCalls(stub func() basil.ID) {
	fake.iDMutex.Lock()
	defer fake.iDMutex.Unlock()
	fake.IDStub = stub
}

func (fake *FakeBlockContainer) IDReturns(result1 basil.ID) {
	fake.iDMutex.Lock()
	defer fake.iDMutex.Unlock()
	fake.IDStub = nil
	fake.iDReturns = struct {
		result1 basil.ID
	}{result1}
}

func (fake *FakeBlockContainer) IDReturnsOnCall(i int, result1 basil.ID) {
	fake.iDMutex.Lock()
	defer fake.iDMutex.Unlock()
	fake.IDStub = nil
	if fake.iDReturnsOnCall == nil {
		fake.iDReturnsOnCall = make(map[int]struct {
			result1 basil.ID
		})
	}
	fake.iDReturnsOnCall[i] = struct {
		result1 basil.ID
	}{result1}
}

func (fake *FakeBlockContainer) JobID() basil.ID {
	fake.jobIDMutex.Lock()
	ret, specificReturn := fake.jobIDReturnsOnCall[len(fake.jobIDArgsForCall)]
	fake.jobIDArgsForCall = append(fake.jobIDArgsForCall, struct {
	}{})
	fake.recordInvocation("JobID", []interface{}{})
	fake.jobIDMutex.Unlock()
	if fake.JobIDStub != nil {
		return fake.JobIDStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.jobIDReturns
	return fakeReturns.result1
}

func (fake *FakeBlockContainer) JobIDCallCount() int {
	fake.jobIDMutex.RLock()
	defer fake.jobIDMutex.RUnlock()
	return len(fake.jobIDArgsForCall)
}

func (fake *FakeBlockContainer) JobIDCalls(stub func() basil.ID) {
	fake.jobIDMutex.Lock()
	defer fake.jobIDMutex.Unlock()
	fake.JobIDStub = stub
}

func (fake *FakeBlockContainer) JobIDReturns(result1 basil.ID) {
	fake.jobIDMutex.Lock()
	defer fake.jobIDMutex.Unlock()
	fake.JobIDStub = nil
	fake.jobIDReturns = struct {
		result1 basil.ID
	}{result1}
}

func (fake *FakeBlockContainer) JobIDReturnsOnCall(i int, result1 basil.ID) {
	fake.jobIDMutex.Lock()
	defer fake.jobIDMutex.Unlock()
	fake.JobIDStub = nil
	if fake.jobIDReturnsOnCall == nil {
		fake.jobIDReturnsOnCall = make(map[int]struct {
			result1 basil.ID
		})
	}
	fake.jobIDReturnsOnCall[i] = struct {
		result1 basil.ID
	}{result1}
}

func (fake *FakeBlockContainer) Lightweight() bool {
	fake.lightweightMutex.Lock()
	ret, specificReturn := fake.lightweightReturnsOnCall[len(fake.lightweightArgsForCall)]
	fake.lightweightArgsForCall = append(fake.lightweightArgsForCall, struct {
	}{})
	fake.recordInvocation("Lightweight", []interface{}{})
	fake.lightweightMutex.Unlock()
	if fake.LightweightStub != nil {
		return fake.LightweightStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.lightweightReturns
	return fakeReturns.result1
}

func (fake *FakeBlockContainer) LightweightCallCount() int {
	fake.lightweightMutex.RLock()
	defer fake.lightweightMutex.RUnlock()
	return len(fake.lightweightArgsForCall)
}

func (fake *FakeBlockContainer) LightweightCalls(stub func() bool) {
	fake.lightweightMutex.Lock()
	defer fake.lightweightMutex.Unlock()
	fake.LightweightStub = stub
}

func (fake *FakeBlockContainer) LightweightReturns(result1 bool) {
	fake.lightweightMutex.Lock()
	defer fake.lightweightMutex.Unlock()
	fake.LightweightStub = nil
	fake.lightweightReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeBlockContainer) LightweightReturnsOnCall(i int, result1 bool) {
	fake.lightweightMutex.Lock()
	defer fake.lightweightMutex.Unlock()
	fake.LightweightStub = nil
	if fake.lightweightReturnsOnCall == nil {
		fake.lightweightReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.lightweightReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeBlockContainer) Node() basil.Node {
	fake.nodeMutex.Lock()
	ret, specificReturn := fake.nodeReturnsOnCall[len(fake.nodeArgsForCall)]
	fake.nodeArgsForCall = append(fake.nodeArgsForCall, struct {
	}{})
	fake.recordInvocation("Node", []interface{}{})
	fake.nodeMutex.Unlock()
	if fake.NodeStub != nil {
		return fake.NodeStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.nodeReturns
	return fakeReturns.result1
}

func (fake *FakeBlockContainer) NodeCallCount() int {
	fake.nodeMutex.RLock()
	defer fake.nodeMutex.RUnlock()
	return len(fake.nodeArgsForCall)
}

func (fake *FakeBlockContainer) NodeCalls(stub func() basil.Node) {
	fake.nodeMutex.Lock()
	defer fake.nodeMutex.Unlock()
	fake.NodeStub = stub
}

func (fake *FakeBlockContainer) NodeReturns(result1 basil.Node) {
	fake.nodeMutex.Lock()
	defer fake.nodeMutex.Unlock()
	fake.NodeStub = nil
	fake.nodeReturns = struct {
		result1 basil.Node
	}{result1}
}

func (fake *FakeBlockContainer) NodeReturnsOnCall(i int, result1 basil.Node) {
	fake.nodeMutex.Lock()
	defer fake.nodeMutex.Unlock()
	fake.NodeStub = nil
	if fake.nodeReturnsOnCall == nil {
		fake.nodeReturnsOnCall = make(map[int]struct {
			result1 basil.Node
		})
	}
	fake.nodeReturnsOnCall[i] = struct {
		result1 basil.Node
	}{result1}
}

func (fake *FakeBlockContainer) Param(arg1 basil.ID) interface{} {
	fake.paramMutex.Lock()
	ret, specificReturn := fake.paramReturnsOnCall[len(fake.paramArgsForCall)]
	fake.paramArgsForCall = append(fake.paramArgsForCall, struct {
		arg1 basil.ID
	}{arg1})
	fake.recordInvocation("Param", []interface{}{arg1})
	fake.paramMutex.Unlock()
	if fake.ParamStub != nil {
		return fake.ParamStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.paramReturns
	return fakeReturns.result1
}

func (fake *FakeBlockContainer) ParamCallCount() int {
	fake.paramMutex.RLock()
	defer fake.paramMutex.RUnlock()
	return len(fake.paramArgsForCall)
}

func (fake *FakeBlockContainer) ParamCalls(stub func(basil.ID) interface{}) {
	fake.paramMutex.Lock()
	defer fake.paramMutex.Unlock()
	fake.ParamStub = stub
}

func (fake *FakeBlockContainer) ParamArgsForCall(i int) basil.ID {
	fake.paramMutex.RLock()
	defer fake.paramMutex.RUnlock()
	argsForCall := fake.paramArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeBlockContainer) ParamReturns(result1 interface{}) {
	fake.paramMutex.Lock()
	defer fake.paramMutex.Unlock()
	fake.ParamStub = nil
	fake.paramReturns = struct {
		result1 interface{}
	}{result1}
}

func (fake *FakeBlockContainer) ParamReturnsOnCall(i int, result1 interface{}) {
	fake.paramMutex.Lock()
	defer fake.paramMutex.Unlock()
	fake.ParamStub = nil
	if fake.paramReturnsOnCall == nil {
		fake.paramReturnsOnCall = make(map[int]struct {
			result1 interface{}
		})
	}
	fake.paramReturnsOnCall[i] = struct {
		result1 interface{}
	}{result1}
}

func (fake *FakeBlockContainer) PublishBlock(arg1 basil.Block) error {
	fake.publishBlockMutex.Lock()
	ret, specificReturn := fake.publishBlockReturnsOnCall[len(fake.publishBlockArgsForCall)]
	fake.publishBlockArgsForCall = append(fake.publishBlockArgsForCall, struct {
		arg1 basil.Block
	}{arg1})
	fake.recordInvocation("PublishBlock", []interface{}{arg1})
	fake.publishBlockMutex.Unlock()
	if fake.PublishBlockStub != nil {
		return fake.PublishBlockStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.publishBlockReturns
	return fakeReturns.result1
}

func (fake *FakeBlockContainer) PublishBlockCallCount() int {
	fake.publishBlockMutex.RLock()
	defer fake.publishBlockMutex.RUnlock()
	return len(fake.publishBlockArgsForCall)
}

func (fake *FakeBlockContainer) PublishBlockCalls(stub func(basil.Block) error) {
	fake.publishBlockMutex.Lock()
	defer fake.publishBlockMutex.Unlock()
	fake.PublishBlockStub = stub
}

func (fake *FakeBlockContainer) PublishBlockArgsForCall(i int) basil.Block {
	fake.publishBlockMutex.RLock()
	defer fake.publishBlockMutex.RUnlock()
	argsForCall := fake.publishBlockArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeBlockContainer) PublishBlockReturns(result1 error) {
	fake.publishBlockMutex.Lock()
	defer fake.publishBlockMutex.Unlock()
	fake.PublishBlockStub = nil
	fake.publishBlockReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeBlockContainer) PublishBlockReturnsOnCall(i int, result1 error) {
	fake.publishBlockMutex.Lock()
	defer fake.publishBlockMutex.Unlock()
	fake.PublishBlockStub = nil
	if fake.publishBlockReturnsOnCall == nil {
		fake.publishBlockReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.publishBlockReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeBlockContainer) Run() {
	fake.runMutex.Lock()
	fake.runArgsForCall = append(fake.runArgsForCall, struct {
	}{})
	fake.recordInvocation("Run", []interface{}{})
	fake.runMutex.Unlock()
	if fake.RunStub != nil {
		fake.RunStub()
	}
}

func (fake *FakeBlockContainer) RunCallCount() int {
	fake.runMutex.RLock()
	defer fake.runMutex.RUnlock()
	return len(fake.runArgsForCall)
}

func (fake *FakeBlockContainer) RunCalls(stub func()) {
	fake.runMutex.Lock()
	defer fake.runMutex.Unlock()
	fake.RunStub = stub
}

func (fake *FakeBlockContainer) SetChild(arg1 basil.Container) {
	fake.setChildMutex.Lock()
	fake.setChildArgsForCall = append(fake.setChildArgsForCall, struct {
		arg1 basil.Container
	}{arg1})
	fake.recordInvocation("SetChild", []interface{}{arg1})
	fake.setChildMutex.Unlock()
	if fake.SetChildStub != nil {
		fake.SetChildStub(arg1)
	}
}

func (fake *FakeBlockContainer) SetChildCallCount() int {
	fake.setChildMutex.RLock()
	defer fake.setChildMutex.RUnlock()
	return len(fake.setChildArgsForCall)
}

func (fake *FakeBlockContainer) SetChildCalls(stub func(basil.Container)) {
	fake.setChildMutex.Lock()
	defer fake.setChildMutex.Unlock()
	fake.SetChildStub = stub
}

func (fake *FakeBlockContainer) SetChildArgsForCall(i int) basil.Container {
	fake.setChildMutex.RLock()
	defer fake.setChildMutex.RUnlock()
	argsForCall := fake.setChildArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeBlockContainer) SetRetry(arg1 basil.Retryable) {
	fake.setRetryMutex.Lock()
	fake.setRetryArgsForCall = append(fake.setRetryArgsForCall, struct {
		arg1 basil.Retryable
	}{arg1})
	fake.recordInvocation("SetRetry", []interface{}{arg1})
	fake.setRetryMutex.Unlock()
	if fake.SetRetryStub != nil {
		fake.SetRetryStub(arg1)
	}
}

func (fake *FakeBlockContainer) SetRetryCallCount() int {
	fake.setRetryMutex.RLock()
	defer fake.setRetryMutex.RUnlock()
	return len(fake.setRetryArgsForCall)
}

func (fake *FakeBlockContainer) SetRetryCalls(stub func(basil.Retryable)) {
	fake.setRetryMutex.Lock()
	defer fake.setRetryMutex.Unlock()
	fake.SetRetryStub = stub
}

func (fake *FakeBlockContainer) SetRetryArgsForCall(i int) basil.Retryable {
	fake.setRetryMutex.RLock()
	defer fake.setRetryMutex.RUnlock()
	argsForCall := fake.setRetryArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeBlockContainer) SetTimeout(arg1 time.Duration) {
	fake.setTimeoutMutex.Lock()
	fake.setTimeoutArgsForCall = append(fake.setTimeoutArgsForCall, struct {
		arg1 time.Duration
	}{arg1})
	fake.recordInvocation("SetTimeout", []interface{}{arg1})
	fake.setTimeoutMutex.Unlock()
	if fake.SetTimeoutStub != nil {
		fake.SetTimeoutStub(arg1)
	}
}

func (fake *FakeBlockContainer) SetTimeoutCallCount() int {
	fake.setTimeoutMutex.RLock()
	defer fake.setTimeoutMutex.RUnlock()
	return len(fake.setTimeoutArgsForCall)
}

func (fake *FakeBlockContainer) SetTimeoutCalls(stub func(time.Duration)) {
	fake.setTimeoutMutex.Lock()
	defer fake.setTimeoutMutex.Unlock()
	fake.SetTimeoutStub = stub
}

func (fake *FakeBlockContainer) SetTimeoutArgsForCall(i int) time.Duration {
	fake.setTimeoutMutex.RLock()
	defer fake.setTimeoutMutex.RUnlock()
	argsForCall := fake.setTimeoutArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeBlockContainer) Skip() {
	fake.skipMutex.Lock()
	fake.skipArgsForCall = append(fake.skipArgsForCall, struct {
	}{})
	fake.recordInvocation("Skip", []interface{}{})
	fake.skipMutex.Unlock()
	if fake.SkipStub != nil {
		fake.SkipStub()
	}
}

func (fake *FakeBlockContainer) SkipCallCount() int {
	fake.skipMutex.RLock()
	defer fake.skipMutex.RUnlock()
	return len(fake.skipArgsForCall)
}

func (fake *FakeBlockContainer) SkipCalls(stub func()) {
	fake.skipMutex.Lock()
	defer fake.skipMutex.Unlock()
	fake.SkipStub = stub
}

func (fake *FakeBlockContainer) Trigger() basil.ID {
	fake.triggerMutex.Lock()
	ret, specificReturn := fake.triggerReturnsOnCall[len(fake.triggerArgsForCall)]
	fake.triggerArgsForCall = append(fake.triggerArgsForCall, struct {
	}{})
	fake.recordInvocation("Trigger", []interface{}{})
	fake.triggerMutex.Unlock()
	if fake.TriggerStub != nil {
		return fake.TriggerStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.triggerReturns
	return fakeReturns.result1
}

func (fake *FakeBlockContainer) TriggerCallCount() int {
	fake.triggerMutex.RLock()
	defer fake.triggerMutex.RUnlock()
	return len(fake.triggerArgsForCall)
}

func (fake *FakeBlockContainer) TriggerCalls(stub func() basil.ID) {
	fake.triggerMutex.Lock()
	defer fake.triggerMutex.Unlock()
	fake.TriggerStub = stub
}

func (fake *FakeBlockContainer) TriggerReturns(result1 basil.ID) {
	fake.triggerMutex.Lock()
	defer fake.triggerMutex.Unlock()
	fake.TriggerStub = nil
	fake.triggerReturns = struct {
		result1 basil.ID
	}{result1}
}

func (fake *FakeBlockContainer) TriggerReturnsOnCall(i int, result1 basil.ID) {
	fake.triggerMutex.Lock()
	defer fake.triggerMutex.Unlock()
	fake.TriggerStub = nil
	if fake.triggerReturnsOnCall == nil {
		fake.triggerReturnsOnCall = make(map[int]struct {
			result1 basil.ID
		})
	}
	fake.triggerReturnsOnCall[i] = struct {
		result1 basil.ID
	}{result1}
}

func (fake *FakeBlockContainer) Value() (interface{}, parsley.Error) {
	fake.valueMutex.Lock()
	ret, specificReturn := fake.valueReturnsOnCall[len(fake.valueArgsForCall)]
	fake.valueArgsForCall = append(fake.valueArgsForCall, struct {
	}{})
	fake.recordInvocation("Value", []interface{}{})
	fake.valueMutex.Unlock()
	if fake.ValueStub != nil {
		return fake.ValueStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.valueReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeBlockContainer) ValueCallCount() int {
	fake.valueMutex.RLock()
	defer fake.valueMutex.RUnlock()
	return len(fake.valueArgsForCall)
}

func (fake *FakeBlockContainer) ValueCalls(stub func() (interface{}, parsley.Error)) {
	fake.valueMutex.Lock()
	defer fake.valueMutex.Unlock()
	fake.ValueStub = stub
}

func (fake *FakeBlockContainer) ValueReturns(result1 interface{}, result2 parsley.Error) {
	fake.valueMutex.Lock()
	defer fake.valueMutex.Unlock()
	fake.ValueStub = nil
	fake.valueReturns = struct {
		result1 interface{}
		result2 parsley.Error
	}{result1, result2}
}

func (fake *FakeBlockContainer) ValueReturnsOnCall(i int, result1 interface{}, result2 parsley.Error) {
	fake.valueMutex.Lock()
	defer fake.valueMutex.Unlock()
	fake.ValueStub = nil
	if fake.valueReturnsOnCall == nil {
		fake.valueReturnsOnCall = make(map[int]struct {
			result1 interface{}
			result2 parsley.Error
		})
	}
	fake.valueReturnsOnCall[i] = struct {
		result1 interface{}
		result2 parsley.Error
	}{result1, result2}
}

func (fake *FakeBlockContainer) WaitGroups() []*util.WaitGroup {
	fake.waitGroupsMutex.Lock()
	ret, specificReturn := fake.waitGroupsReturnsOnCall[len(fake.waitGroupsArgsForCall)]
	fake.waitGroupsArgsForCall = append(fake.waitGroupsArgsForCall, struct {
	}{})
	fake.recordInvocation("WaitGroups", []interface{}{})
	fake.waitGroupsMutex.Unlock()
	if fake.WaitGroupsStub != nil {
		return fake.WaitGroupsStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.waitGroupsReturns
	return fakeReturns.result1
}

func (fake *FakeBlockContainer) WaitGroupsCallCount() int {
	fake.waitGroupsMutex.RLock()
	defer fake.waitGroupsMutex.RUnlock()
	return len(fake.waitGroupsArgsForCall)
}

func (fake *FakeBlockContainer) WaitGroupsCalls(stub func() []*util.WaitGroup) {
	fake.waitGroupsMutex.Lock()
	defer fake.waitGroupsMutex.Unlock()
	fake.WaitGroupsStub = stub
}

func (fake *FakeBlockContainer) WaitGroupsReturns(result1 []*util.WaitGroup) {
	fake.waitGroupsMutex.Lock()
	defer fake.waitGroupsMutex.Unlock()
	fake.WaitGroupsStub = nil
	fake.waitGroupsReturns = struct {
		result1 []*util.WaitGroup
	}{result1}
}

func (fake *FakeBlockContainer) WaitGroupsReturnsOnCall(i int, result1 []*util.WaitGroup) {
	fake.waitGroupsMutex.Lock()
	defer fake.waitGroupsMutex.Unlock()
	fake.WaitGroupsStub = nil
	if fake.waitGroupsReturnsOnCall == nil {
		fake.waitGroupsReturnsOnCall = make(map[int]struct {
			result1 []*util.WaitGroup
		})
	}
	fake.waitGroupsReturnsOnCall[i] = struct {
		result1 []*util.WaitGroup
	}{result1}
}

func (fake *FakeBlockContainer) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.blockMutex.RLock()
	defer fake.blockMutex.RUnlock()
	fake.cancelMutex.RLock()
	defer fake.cancelMutex.RUnlock()
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	fake.evaluateChildMutex.RLock()
	defer fake.evaluateChildMutex.RUnlock()
	fake.iDMutex.RLock()
	defer fake.iDMutex.RUnlock()
	fake.jobIDMutex.RLock()
	defer fake.jobIDMutex.RUnlock()
	fake.lightweightMutex.RLock()
	defer fake.lightweightMutex.RUnlock()
	fake.nodeMutex.RLock()
	defer fake.nodeMutex.RUnlock()
	fake.paramMutex.RLock()
	defer fake.paramMutex.RUnlock()
	fake.publishBlockMutex.RLock()
	defer fake.publishBlockMutex.RUnlock()
	fake.runMutex.RLock()
	defer fake.runMutex.RUnlock()
	fake.setChildMutex.RLock()
	defer fake.setChildMutex.RUnlock()
	fake.setRetryMutex.RLock()
	defer fake.setRetryMutex.RUnlock()
	fake.setTimeoutMutex.RLock()
	defer fake.setTimeoutMutex.RUnlock()
	fake.skipMutex.RLock()
	defer fake.skipMutex.RUnlock()
	fake.triggerMutex.RLock()
	defer fake.triggerMutex.RUnlock()
	fake.valueMutex.RLock()
	defer fake.valueMutex.RUnlock()
	fake.waitGroupsMutex.RLock()
	defer fake.waitGroupsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeBlockContainer) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ basil.BlockContainer = new(FakeBlockContainer)
