// Code generated by counterfeiter. DO NOT EDIT.
package basilfakes

import (
	"sync"

	"github.com/opsidian/basil/basil"
	"github.com/opsidian/basil/variable"
	"github.com/opsidian/parsley/parsley"
)

type FakeBlockNode struct {
	TokenStub        func() string
	tokenMutex       sync.RWMutex
	tokenArgsForCall []struct{}
	tokenReturns     struct {
		result1 string
	}
	tokenReturnsOnCall map[int]struct {
		result1 string
	}
	TypeStub        func() string
	typeMutex       sync.RWMutex
	typeArgsForCall []struct{}
	typeReturns     struct {
		result1 string
	}
	typeReturnsOnCall map[int]struct {
		result1 string
	}
	ValueStub        func(userCtx interface{}) (interface{}, parsley.Error)
	valueMutex       sync.RWMutex
	valueArgsForCall []struct {
		userCtx interface{}
	}
	valueReturns struct {
		result1 interface{}
		result2 parsley.Error
	}
	valueReturnsOnCall map[int]struct {
		result1 interface{}
		result2 parsley.Error
	}
	PosStub        func() parsley.Pos
	posMutex       sync.RWMutex
	posArgsForCall []struct{}
	posReturns     struct {
		result1 parsley.Pos
	}
	posReturnsOnCall map[int]struct {
		result1 parsley.Pos
	}
	ReaderPosStub        func() parsley.Pos
	readerPosMutex       sync.RWMutex
	readerPosArgsForCall []struct{}
	readerPosReturns     struct {
		result1 parsley.Pos
	}
	readerPosReturnsOnCall map[int]struct {
		result1 parsley.Pos
	}
	StaticCheckStub        func(userCtx interface{}) parsley.Error
	staticCheckMutex       sync.RWMutex
	staticCheckArgsForCall []struct {
		userCtx interface{}
	}
	staticCheckReturns struct {
		result1 parsley.Error
	}
	staticCheckReturnsOnCall map[int]struct {
		result1 parsley.Error
	}
	EvalStub        func(ctx interface{}, stage string, block basil.Block) parsley.Error
	evalMutex       sync.RWMutex
	evalArgsForCall []struct {
		ctx   interface{}
		stage string
		block basil.Block
	}
	evalReturns struct {
		result1 parsley.Error
	}
	evalReturnsOnCall map[int]struct {
		result1 parsley.Error
	}
	IDStub        func() variable.ID
	iDMutex       sync.RWMutex
	iDArgsForCall []struct{}
	iDReturns     struct {
		result1 variable.ID
	}
	iDReturnsOnCall map[int]struct {
		result1 variable.ID
	}
	ParamNodesStub        func() map[variable.ID]basil.BlockParamNode
	paramNodesMutex       sync.RWMutex
	paramNodesArgsForCall []struct{}
	paramNodesReturns     struct {
		result1 map[variable.ID]basil.BlockParamNode
	}
	paramNodesReturnsOnCall map[int]struct {
		result1 map[variable.ID]basil.BlockParamNode
	}
	BlockNodesStub        func() []basil.BlockNode
	blockNodesMutex       sync.RWMutex
	blockNodesArgsForCall []struct{}
	blockNodesReturns     struct {
		result1 []basil.BlockNode
	}
	blockNodesReturnsOnCall map[int]struct {
		result1 []basil.BlockNode
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeBlockNode) Token() string {
	fake.tokenMutex.Lock()
	ret, specificReturn := fake.tokenReturnsOnCall[len(fake.tokenArgsForCall)]
	fake.tokenArgsForCall = append(fake.tokenArgsForCall, struct{}{})
	fake.recordInvocation("Token", []interface{}{})
	fake.tokenMutex.Unlock()
	if fake.TokenStub != nil {
		return fake.TokenStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.tokenReturns.result1
}

func (fake *FakeBlockNode) TokenCallCount() int {
	fake.tokenMutex.RLock()
	defer fake.tokenMutex.RUnlock()
	return len(fake.tokenArgsForCall)
}

func (fake *FakeBlockNode) TokenReturns(result1 string) {
	fake.TokenStub = nil
	fake.tokenReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeBlockNode) TokenReturnsOnCall(i int, result1 string) {
	fake.TokenStub = nil
	if fake.tokenReturnsOnCall == nil {
		fake.tokenReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.tokenReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeBlockNode) Type() string {
	fake.typeMutex.Lock()
	ret, specificReturn := fake.typeReturnsOnCall[len(fake.typeArgsForCall)]
	fake.typeArgsForCall = append(fake.typeArgsForCall, struct{}{})
	fake.recordInvocation("Type", []interface{}{})
	fake.typeMutex.Unlock()
	if fake.TypeStub != nil {
		return fake.TypeStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.typeReturns.result1
}

func (fake *FakeBlockNode) TypeCallCount() int {
	fake.typeMutex.RLock()
	defer fake.typeMutex.RUnlock()
	return len(fake.typeArgsForCall)
}

func (fake *FakeBlockNode) TypeReturns(result1 string) {
	fake.TypeStub = nil
	fake.typeReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeBlockNode) TypeReturnsOnCall(i int, result1 string) {
	fake.TypeStub = nil
	if fake.typeReturnsOnCall == nil {
		fake.typeReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.typeReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeBlockNode) Value(userCtx interface{}) (interface{}, parsley.Error) {
	fake.valueMutex.Lock()
	ret, specificReturn := fake.valueReturnsOnCall[len(fake.valueArgsForCall)]
	fake.valueArgsForCall = append(fake.valueArgsForCall, struct {
		userCtx interface{}
	}{userCtx})
	fake.recordInvocation("Value", []interface{}{userCtx})
	fake.valueMutex.Unlock()
	if fake.ValueStub != nil {
		return fake.ValueStub(userCtx)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.valueReturns.result1, fake.valueReturns.result2
}

func (fake *FakeBlockNode) ValueCallCount() int {
	fake.valueMutex.RLock()
	defer fake.valueMutex.RUnlock()
	return len(fake.valueArgsForCall)
}

func (fake *FakeBlockNode) ValueArgsForCall(i int) interface{} {
	fake.valueMutex.RLock()
	defer fake.valueMutex.RUnlock()
	return fake.valueArgsForCall[i].userCtx
}

func (fake *FakeBlockNode) ValueReturns(result1 interface{}, result2 parsley.Error) {
	fake.ValueStub = nil
	fake.valueReturns = struct {
		result1 interface{}
		result2 parsley.Error
	}{result1, result2}
}

func (fake *FakeBlockNode) ValueReturnsOnCall(i int, result1 interface{}, result2 parsley.Error) {
	fake.ValueStub = nil
	if fake.valueReturnsOnCall == nil {
		fake.valueReturnsOnCall = make(map[int]struct {
			result1 interface{}
			result2 parsley.Error
		})
	}
	fake.valueReturnsOnCall[i] = struct {
		result1 interface{}
		result2 parsley.Error
	}{result1, result2}
}

func (fake *FakeBlockNode) Pos() parsley.Pos {
	fake.posMutex.Lock()
	ret, specificReturn := fake.posReturnsOnCall[len(fake.posArgsForCall)]
	fake.posArgsForCall = append(fake.posArgsForCall, struct{}{})
	fake.recordInvocation("Pos", []interface{}{})
	fake.posMutex.Unlock()
	if fake.PosStub != nil {
		return fake.PosStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.posReturns.result1
}

func (fake *FakeBlockNode) PosCallCount() int {
	fake.posMutex.RLock()
	defer fake.posMutex.RUnlock()
	return len(fake.posArgsForCall)
}

func (fake *FakeBlockNode) PosReturns(result1 parsley.Pos) {
	fake.PosStub = nil
	fake.posReturns = struct {
		result1 parsley.Pos
	}{result1}
}

func (fake *FakeBlockNode) PosReturnsOnCall(i int, result1 parsley.Pos) {
	fake.PosStub = nil
	if fake.posReturnsOnCall == nil {
		fake.posReturnsOnCall = make(map[int]struct {
			result1 parsley.Pos
		})
	}
	fake.posReturnsOnCall[i] = struct {
		result1 parsley.Pos
	}{result1}
}

func (fake *FakeBlockNode) ReaderPos() parsley.Pos {
	fake.readerPosMutex.Lock()
	ret, specificReturn := fake.readerPosReturnsOnCall[len(fake.readerPosArgsForCall)]
	fake.readerPosArgsForCall = append(fake.readerPosArgsForCall, struct{}{})
	fake.recordInvocation("ReaderPos", []interface{}{})
	fake.readerPosMutex.Unlock()
	if fake.ReaderPosStub != nil {
		return fake.ReaderPosStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.readerPosReturns.result1
}

func (fake *FakeBlockNode) ReaderPosCallCount() int {
	fake.readerPosMutex.RLock()
	defer fake.readerPosMutex.RUnlock()
	return len(fake.readerPosArgsForCall)
}

func (fake *FakeBlockNode) ReaderPosReturns(result1 parsley.Pos) {
	fake.ReaderPosStub = nil
	fake.readerPosReturns = struct {
		result1 parsley.Pos
	}{result1}
}

func (fake *FakeBlockNode) ReaderPosReturnsOnCall(i int, result1 parsley.Pos) {
	fake.ReaderPosStub = nil
	if fake.readerPosReturnsOnCall == nil {
		fake.readerPosReturnsOnCall = make(map[int]struct {
			result1 parsley.Pos
		})
	}
	fake.readerPosReturnsOnCall[i] = struct {
		result1 parsley.Pos
	}{result1}
}

func (fake *FakeBlockNode) StaticCheck(userCtx interface{}) parsley.Error {
	fake.staticCheckMutex.Lock()
	ret, specificReturn := fake.staticCheckReturnsOnCall[len(fake.staticCheckArgsForCall)]
	fake.staticCheckArgsForCall = append(fake.staticCheckArgsForCall, struct {
		userCtx interface{}
	}{userCtx})
	fake.recordInvocation("StaticCheck", []interface{}{userCtx})
	fake.staticCheckMutex.Unlock()
	if fake.StaticCheckStub != nil {
		return fake.StaticCheckStub(userCtx)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.staticCheckReturns.result1
}

func (fake *FakeBlockNode) StaticCheckCallCount() int {
	fake.staticCheckMutex.RLock()
	defer fake.staticCheckMutex.RUnlock()
	return len(fake.staticCheckArgsForCall)
}

func (fake *FakeBlockNode) StaticCheckArgsForCall(i int) interface{} {
	fake.staticCheckMutex.RLock()
	defer fake.staticCheckMutex.RUnlock()
	return fake.staticCheckArgsForCall[i].userCtx
}

func (fake *FakeBlockNode) StaticCheckReturns(result1 parsley.Error) {
	fake.StaticCheckStub = nil
	fake.staticCheckReturns = struct {
		result1 parsley.Error
	}{result1}
}

func (fake *FakeBlockNode) StaticCheckReturnsOnCall(i int, result1 parsley.Error) {
	fake.StaticCheckStub = nil
	if fake.staticCheckReturnsOnCall == nil {
		fake.staticCheckReturnsOnCall = make(map[int]struct {
			result1 parsley.Error
		})
	}
	fake.staticCheckReturnsOnCall[i] = struct {
		result1 parsley.Error
	}{result1}
}

func (fake *FakeBlockNode) Eval(ctx interface{}, stage string, block basil.Block) parsley.Error {
	fake.evalMutex.Lock()
	ret, specificReturn := fake.evalReturnsOnCall[len(fake.evalArgsForCall)]
	fake.evalArgsForCall = append(fake.evalArgsForCall, struct {
		ctx   interface{}
		stage string
		block basil.Block
	}{ctx, stage, block})
	fake.recordInvocation("Eval", []interface{}{ctx, stage, block})
	fake.evalMutex.Unlock()
	if fake.EvalStub != nil {
		return fake.EvalStub(ctx, stage, block)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.evalReturns.result1
}

func (fake *FakeBlockNode) EvalCallCount() int {
	fake.evalMutex.RLock()
	defer fake.evalMutex.RUnlock()
	return len(fake.evalArgsForCall)
}

func (fake *FakeBlockNode) EvalArgsForCall(i int) (interface{}, string, basil.Block) {
	fake.evalMutex.RLock()
	defer fake.evalMutex.RUnlock()
	return fake.evalArgsForCall[i].ctx, fake.evalArgsForCall[i].stage, fake.evalArgsForCall[i].block
}

func (fake *FakeBlockNode) EvalReturns(result1 parsley.Error) {
	fake.EvalStub = nil
	fake.evalReturns = struct {
		result1 parsley.Error
	}{result1}
}

func (fake *FakeBlockNode) EvalReturnsOnCall(i int, result1 parsley.Error) {
	fake.EvalStub = nil
	if fake.evalReturnsOnCall == nil {
		fake.evalReturnsOnCall = make(map[int]struct {
			result1 parsley.Error
		})
	}
	fake.evalReturnsOnCall[i] = struct {
		result1 parsley.Error
	}{result1}
}

func (fake *FakeBlockNode) ID() variable.ID {
	fake.iDMutex.Lock()
	ret, specificReturn := fake.iDReturnsOnCall[len(fake.iDArgsForCall)]
	fake.iDArgsForCall = append(fake.iDArgsForCall, struct{}{})
	fake.recordInvocation("ID", []interface{}{})
	fake.iDMutex.Unlock()
	if fake.IDStub != nil {
		return fake.IDStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.iDReturns.result1
}

func (fake *FakeBlockNode) IDCallCount() int {
	fake.iDMutex.RLock()
	defer fake.iDMutex.RUnlock()
	return len(fake.iDArgsForCall)
}

func (fake *FakeBlockNode) IDReturns(result1 variable.ID) {
	fake.IDStub = nil
	fake.iDReturns = struct {
		result1 variable.ID
	}{result1}
}

func (fake *FakeBlockNode) IDReturnsOnCall(i int, result1 variable.ID) {
	fake.IDStub = nil
	if fake.iDReturnsOnCall == nil {
		fake.iDReturnsOnCall = make(map[int]struct {
			result1 variable.ID
		})
	}
	fake.iDReturnsOnCall[i] = struct {
		result1 variable.ID
	}{result1}
}

func (fake *FakeBlockNode) ParamNodes() map[variable.ID]basil.BlockParamNode {
	fake.paramNodesMutex.Lock()
	ret, specificReturn := fake.paramNodesReturnsOnCall[len(fake.paramNodesArgsForCall)]
	fake.paramNodesArgsForCall = append(fake.paramNodesArgsForCall, struct{}{})
	fake.recordInvocation("ParamNodes", []interface{}{})
	fake.paramNodesMutex.Unlock()
	if fake.ParamNodesStub != nil {
		return fake.ParamNodesStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.paramNodesReturns.result1
}

func (fake *FakeBlockNode) ParamNodesCallCount() int {
	fake.paramNodesMutex.RLock()
	defer fake.paramNodesMutex.RUnlock()
	return len(fake.paramNodesArgsForCall)
}

func (fake *FakeBlockNode) ParamNodesReturns(result1 map[variable.ID]basil.BlockParamNode) {
	fake.ParamNodesStub = nil
	fake.paramNodesReturns = struct {
		result1 map[variable.ID]basil.BlockParamNode
	}{result1}
}

func (fake *FakeBlockNode) ParamNodesReturnsOnCall(i int, result1 map[variable.ID]basil.BlockParamNode) {
	fake.ParamNodesStub = nil
	if fake.paramNodesReturnsOnCall == nil {
		fake.paramNodesReturnsOnCall = make(map[int]struct {
			result1 map[variable.ID]basil.BlockParamNode
		})
	}
	fake.paramNodesReturnsOnCall[i] = struct {
		result1 map[variable.ID]basil.BlockParamNode
	}{result1}
}

func (fake *FakeBlockNode) BlockNodes() []basil.BlockNode {
	fake.blockNodesMutex.Lock()
	ret, specificReturn := fake.blockNodesReturnsOnCall[len(fake.blockNodesArgsForCall)]
	fake.blockNodesArgsForCall = append(fake.blockNodesArgsForCall, struct{}{})
	fake.recordInvocation("BlockNodes", []interface{}{})
	fake.blockNodesMutex.Unlock()
	if fake.BlockNodesStub != nil {
		return fake.BlockNodesStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.blockNodesReturns.result1
}

func (fake *FakeBlockNode) BlockNodesCallCount() int {
	fake.blockNodesMutex.RLock()
	defer fake.blockNodesMutex.RUnlock()
	return len(fake.blockNodesArgsForCall)
}

func (fake *FakeBlockNode) BlockNodesReturns(result1 []basil.BlockNode) {
	fake.BlockNodesStub = nil
	fake.blockNodesReturns = struct {
		result1 []basil.BlockNode
	}{result1}
}

func (fake *FakeBlockNode) BlockNodesReturnsOnCall(i int, result1 []basil.BlockNode) {
	fake.BlockNodesStub = nil
	if fake.blockNodesReturnsOnCall == nil {
		fake.blockNodesReturnsOnCall = make(map[int]struct {
			result1 []basil.BlockNode
		})
	}
	fake.blockNodesReturnsOnCall[i] = struct {
		result1 []basil.BlockNode
	}{result1}
}

func (fake *FakeBlockNode) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.tokenMutex.RLock()
	defer fake.tokenMutex.RUnlock()
	fake.typeMutex.RLock()
	defer fake.typeMutex.RUnlock()
	fake.valueMutex.RLock()
	defer fake.valueMutex.RUnlock()
	fake.posMutex.RLock()
	defer fake.posMutex.RUnlock()
	fake.readerPosMutex.RLock()
	defer fake.readerPosMutex.RUnlock()
	fake.staticCheckMutex.RLock()
	defer fake.staticCheckMutex.RUnlock()
	fake.evalMutex.RLock()
	defer fake.evalMutex.RUnlock()
	fake.iDMutex.RLock()
	defer fake.iDMutex.RUnlock()
	fake.paramNodesMutex.RLock()
	defer fake.paramNodesMutex.RUnlock()
	fake.blockNodesMutex.RLock()
	defer fake.blockNodesMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeBlockNode) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ basil.BlockNode = new(FakeBlockNode)
