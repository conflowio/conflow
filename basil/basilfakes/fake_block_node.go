// Code generated by counterfeiter. DO NOT EDIT.
package basilfakes

import (
	"sync"

	"github.com/opsidian/basil/basil"
	"github.com/opsidian/parsley/parsley"
)

type FakeBlockNode struct {
	TokenStub        func() string
	tokenMutex       sync.RWMutex
	tokenArgsForCall []struct{}
	tokenReturns     struct {
		result1 string
	}
	tokenReturnsOnCall map[int]struct {
		result1 string
	}
	TypeStub        func() string
	typeMutex       sync.RWMutex
	typeArgsForCall []struct{}
	typeReturns     struct {
		result1 string
	}
	typeReturnsOnCall map[int]struct {
		result1 string
	}
	ValueStub        func(userCtx interface{}) (interface{}, parsley.Error)
	valueMutex       sync.RWMutex
	valueArgsForCall []struct {
		userCtx interface{}
	}
	valueReturns struct {
		result1 interface{}
		result2 parsley.Error
	}
	valueReturnsOnCall map[int]struct {
		result1 interface{}
		result2 parsley.Error
	}
	PosStub        func() parsley.Pos
	posMutex       sync.RWMutex
	posArgsForCall []struct{}
	posReturns     struct {
		result1 parsley.Pos
	}
	posReturnsOnCall map[int]struct {
		result1 parsley.Pos
	}
	ReaderPosStub        func() parsley.Pos
	readerPosMutex       sync.RWMutex
	readerPosArgsForCall []struct{}
	readerPosReturns     struct {
		result1 parsley.Pos
	}
	readerPosReturnsOnCall map[int]struct {
		result1 parsley.Pos
	}
	ChildrenStub        func() []parsley.Node
	childrenMutex       sync.RWMutex
	childrenArgsForCall []struct{}
	childrenReturns     struct {
		result1 []parsley.Node
	}
	childrenReturnsOnCall map[int]struct {
		result1 []parsley.Node
	}
	IDStub        func() basil.ID
	iDMutex       sync.RWMutex
	iDArgsForCall []struct{}
	iDReturns     struct {
		result1 basil.ID
	}
	iDReturnsOnCall map[int]struct {
		result1 basil.ID
	}
	DependenciesStub        func() []parsley.Node
	dependenciesMutex       sync.RWMutex
	dependenciesArgsForCall []struct{}
	dependenciesReturns     struct {
		result1 []parsley.Node
	}
	dependenciesReturnsOnCall map[int]struct {
		result1 []parsley.Node
	}
	EvalStageStub        func() basil.EvalStage
	evalStageMutex       sync.RWMutex
	evalStageArgsForCall []struct{}
	evalStageReturns     struct {
		result1 basil.EvalStage
	}
	evalStageReturnsOnCall map[int]struct {
		result1 basil.EvalStage
	}
	IDNodeStub        func() parsley.Node
	iDNodeMutex       sync.RWMutex
	iDNodeArgsForCall []struct{}
	iDNodeReturns     struct {
		result1 parsley.Node
	}
	iDNodeReturnsOnCall map[int]struct {
		result1 parsley.Node
	}
	TypeNodeStub        func() parsley.Node
	typeNodeMutex       sync.RWMutex
	typeNodeArgsForCall []struct{}
	typeNodeReturns     struct {
		result1 parsley.Node
	}
	typeNodeReturnsOnCall map[int]struct {
		result1 parsley.Node
	}
	ParamTypeStub        func(basil.ID) (string, bool)
	paramTypeMutex       sync.RWMutex
	paramTypeArgsForCall []struct {
		arg1 basil.ID
	}
	paramTypeReturns struct {
		result1 string
		result2 bool
	}
	paramTypeReturnsOnCall map[int]struct {
		result1 string
		result2 bool
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeBlockNode) Token() string {
	fake.tokenMutex.Lock()
	ret, specificReturn := fake.tokenReturnsOnCall[len(fake.tokenArgsForCall)]
	fake.tokenArgsForCall = append(fake.tokenArgsForCall, struct{}{})
	fake.recordInvocation("Token", []interface{}{})
	fake.tokenMutex.Unlock()
	if fake.TokenStub != nil {
		return fake.TokenStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.tokenReturns.result1
}

func (fake *FakeBlockNode) TokenCallCount() int {
	fake.tokenMutex.RLock()
	defer fake.tokenMutex.RUnlock()
	return len(fake.tokenArgsForCall)
}

func (fake *FakeBlockNode) TokenReturns(result1 string) {
	fake.TokenStub = nil
	fake.tokenReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeBlockNode) TokenReturnsOnCall(i int, result1 string) {
	fake.TokenStub = nil
	if fake.tokenReturnsOnCall == nil {
		fake.tokenReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.tokenReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeBlockNode) Type() string {
	fake.typeMutex.Lock()
	ret, specificReturn := fake.typeReturnsOnCall[len(fake.typeArgsForCall)]
	fake.typeArgsForCall = append(fake.typeArgsForCall, struct{}{})
	fake.recordInvocation("Type", []interface{}{})
	fake.typeMutex.Unlock()
	if fake.TypeStub != nil {
		return fake.TypeStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.typeReturns.result1
}

func (fake *FakeBlockNode) TypeCallCount() int {
	fake.typeMutex.RLock()
	defer fake.typeMutex.RUnlock()
	return len(fake.typeArgsForCall)
}

func (fake *FakeBlockNode) TypeReturns(result1 string) {
	fake.TypeStub = nil
	fake.typeReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeBlockNode) TypeReturnsOnCall(i int, result1 string) {
	fake.TypeStub = nil
	if fake.typeReturnsOnCall == nil {
		fake.typeReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.typeReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeBlockNode) Value(userCtx interface{}) (interface{}, parsley.Error) {
	fake.valueMutex.Lock()
	ret, specificReturn := fake.valueReturnsOnCall[len(fake.valueArgsForCall)]
	fake.valueArgsForCall = append(fake.valueArgsForCall, struct {
		userCtx interface{}
	}{userCtx})
	fake.recordInvocation("Value", []interface{}{userCtx})
	fake.valueMutex.Unlock()
	if fake.ValueStub != nil {
		return fake.ValueStub(userCtx)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.valueReturns.result1, fake.valueReturns.result2
}

func (fake *FakeBlockNode) ValueCallCount() int {
	fake.valueMutex.RLock()
	defer fake.valueMutex.RUnlock()
	return len(fake.valueArgsForCall)
}

func (fake *FakeBlockNode) ValueArgsForCall(i int) interface{} {
	fake.valueMutex.RLock()
	defer fake.valueMutex.RUnlock()
	return fake.valueArgsForCall[i].userCtx
}

func (fake *FakeBlockNode) ValueReturns(result1 interface{}, result2 parsley.Error) {
	fake.ValueStub = nil
	fake.valueReturns = struct {
		result1 interface{}
		result2 parsley.Error
	}{result1, result2}
}

func (fake *FakeBlockNode) ValueReturnsOnCall(i int, result1 interface{}, result2 parsley.Error) {
	fake.ValueStub = nil
	if fake.valueReturnsOnCall == nil {
		fake.valueReturnsOnCall = make(map[int]struct {
			result1 interface{}
			result2 parsley.Error
		})
	}
	fake.valueReturnsOnCall[i] = struct {
		result1 interface{}
		result2 parsley.Error
	}{result1, result2}
}

func (fake *FakeBlockNode) Pos() parsley.Pos {
	fake.posMutex.Lock()
	ret, specificReturn := fake.posReturnsOnCall[len(fake.posArgsForCall)]
	fake.posArgsForCall = append(fake.posArgsForCall, struct{}{})
	fake.recordInvocation("Pos", []interface{}{})
	fake.posMutex.Unlock()
	if fake.PosStub != nil {
		return fake.PosStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.posReturns.result1
}

func (fake *FakeBlockNode) PosCallCount() int {
	fake.posMutex.RLock()
	defer fake.posMutex.RUnlock()
	return len(fake.posArgsForCall)
}

func (fake *FakeBlockNode) PosReturns(result1 parsley.Pos) {
	fake.PosStub = nil
	fake.posReturns = struct {
		result1 parsley.Pos
	}{result1}
}

func (fake *FakeBlockNode) PosReturnsOnCall(i int, result1 parsley.Pos) {
	fake.PosStub = nil
	if fake.posReturnsOnCall == nil {
		fake.posReturnsOnCall = make(map[int]struct {
			result1 parsley.Pos
		})
	}
	fake.posReturnsOnCall[i] = struct {
		result1 parsley.Pos
	}{result1}
}

func (fake *FakeBlockNode) ReaderPos() parsley.Pos {
	fake.readerPosMutex.Lock()
	ret, specificReturn := fake.readerPosReturnsOnCall[len(fake.readerPosArgsForCall)]
	fake.readerPosArgsForCall = append(fake.readerPosArgsForCall, struct{}{})
	fake.recordInvocation("ReaderPos", []interface{}{})
	fake.readerPosMutex.Unlock()
	if fake.ReaderPosStub != nil {
		return fake.ReaderPosStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.readerPosReturns.result1
}

func (fake *FakeBlockNode) ReaderPosCallCount() int {
	fake.readerPosMutex.RLock()
	defer fake.readerPosMutex.RUnlock()
	return len(fake.readerPosArgsForCall)
}

func (fake *FakeBlockNode) ReaderPosReturns(result1 parsley.Pos) {
	fake.ReaderPosStub = nil
	fake.readerPosReturns = struct {
		result1 parsley.Pos
	}{result1}
}

func (fake *FakeBlockNode) ReaderPosReturnsOnCall(i int, result1 parsley.Pos) {
	fake.ReaderPosStub = nil
	if fake.readerPosReturnsOnCall == nil {
		fake.readerPosReturnsOnCall = make(map[int]struct {
			result1 parsley.Pos
		})
	}
	fake.readerPosReturnsOnCall[i] = struct {
		result1 parsley.Pos
	}{result1}
}

func (fake *FakeBlockNode) Children() []parsley.Node {
	fake.childrenMutex.Lock()
	ret, specificReturn := fake.childrenReturnsOnCall[len(fake.childrenArgsForCall)]
	fake.childrenArgsForCall = append(fake.childrenArgsForCall, struct{}{})
	fake.recordInvocation("Children", []interface{}{})
	fake.childrenMutex.Unlock()
	if fake.ChildrenStub != nil {
		return fake.ChildrenStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.childrenReturns.result1
}

func (fake *FakeBlockNode) ChildrenCallCount() int {
	fake.childrenMutex.RLock()
	defer fake.childrenMutex.RUnlock()
	return len(fake.childrenArgsForCall)
}

func (fake *FakeBlockNode) ChildrenReturns(result1 []parsley.Node) {
	fake.ChildrenStub = nil
	fake.childrenReturns = struct {
		result1 []parsley.Node
	}{result1}
}

func (fake *FakeBlockNode) ChildrenReturnsOnCall(i int, result1 []parsley.Node) {
	fake.ChildrenStub = nil
	if fake.childrenReturnsOnCall == nil {
		fake.childrenReturnsOnCall = make(map[int]struct {
			result1 []parsley.Node
		})
	}
	fake.childrenReturnsOnCall[i] = struct {
		result1 []parsley.Node
	}{result1}
}

func (fake *FakeBlockNode) ID() basil.ID {
	fake.iDMutex.Lock()
	ret, specificReturn := fake.iDReturnsOnCall[len(fake.iDArgsForCall)]
	fake.iDArgsForCall = append(fake.iDArgsForCall, struct{}{})
	fake.recordInvocation("ID", []interface{}{})
	fake.iDMutex.Unlock()
	if fake.IDStub != nil {
		return fake.IDStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.iDReturns.result1
}

func (fake *FakeBlockNode) IDCallCount() int {
	fake.iDMutex.RLock()
	defer fake.iDMutex.RUnlock()
	return len(fake.iDArgsForCall)
}

func (fake *FakeBlockNode) IDReturns(result1 basil.ID) {
	fake.IDStub = nil
	fake.iDReturns = struct {
		result1 basil.ID
	}{result1}
}

func (fake *FakeBlockNode) IDReturnsOnCall(i int, result1 basil.ID) {
	fake.IDStub = nil
	if fake.iDReturnsOnCall == nil {
		fake.iDReturnsOnCall = make(map[int]struct {
			result1 basil.ID
		})
	}
	fake.iDReturnsOnCall[i] = struct {
		result1 basil.ID
	}{result1}
}

func (fake *FakeBlockNode) Dependencies() []parsley.Node {
	fake.dependenciesMutex.Lock()
	ret, specificReturn := fake.dependenciesReturnsOnCall[len(fake.dependenciesArgsForCall)]
	fake.dependenciesArgsForCall = append(fake.dependenciesArgsForCall, struct{}{})
	fake.recordInvocation("Dependencies", []interface{}{})
	fake.dependenciesMutex.Unlock()
	if fake.DependenciesStub != nil {
		return fake.DependenciesStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.dependenciesReturns.result1
}

func (fake *FakeBlockNode) DependenciesCallCount() int {
	fake.dependenciesMutex.RLock()
	defer fake.dependenciesMutex.RUnlock()
	return len(fake.dependenciesArgsForCall)
}

func (fake *FakeBlockNode) DependenciesReturns(result1 []parsley.Node) {
	fake.DependenciesStub = nil
	fake.dependenciesReturns = struct {
		result1 []parsley.Node
	}{result1}
}

func (fake *FakeBlockNode) DependenciesReturnsOnCall(i int, result1 []parsley.Node) {
	fake.DependenciesStub = nil
	if fake.dependenciesReturnsOnCall == nil {
		fake.dependenciesReturnsOnCall = make(map[int]struct {
			result1 []parsley.Node
		})
	}
	fake.dependenciesReturnsOnCall[i] = struct {
		result1 []parsley.Node
	}{result1}
}

func (fake *FakeBlockNode) EvalStage() basil.EvalStage {
	fake.evalStageMutex.Lock()
	ret, specificReturn := fake.evalStageReturnsOnCall[len(fake.evalStageArgsForCall)]
	fake.evalStageArgsForCall = append(fake.evalStageArgsForCall, struct{}{})
	fake.recordInvocation("EvalStage", []interface{}{})
	fake.evalStageMutex.Unlock()
	if fake.EvalStageStub != nil {
		return fake.EvalStageStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.evalStageReturns.result1
}

func (fake *FakeBlockNode) EvalStageCallCount() int {
	fake.evalStageMutex.RLock()
	defer fake.evalStageMutex.RUnlock()
	return len(fake.evalStageArgsForCall)
}

func (fake *FakeBlockNode) EvalStageReturns(result1 basil.EvalStage) {
	fake.EvalStageStub = nil
	fake.evalStageReturns = struct {
		result1 basil.EvalStage
	}{result1}
}

func (fake *FakeBlockNode) EvalStageReturnsOnCall(i int, result1 basil.EvalStage) {
	fake.EvalStageStub = nil
	if fake.evalStageReturnsOnCall == nil {
		fake.evalStageReturnsOnCall = make(map[int]struct {
			result1 basil.EvalStage
		})
	}
	fake.evalStageReturnsOnCall[i] = struct {
		result1 basil.EvalStage
	}{result1}
}

func (fake *FakeBlockNode) IDNode() parsley.Node {
	fake.iDNodeMutex.Lock()
	ret, specificReturn := fake.iDNodeReturnsOnCall[len(fake.iDNodeArgsForCall)]
	fake.iDNodeArgsForCall = append(fake.iDNodeArgsForCall, struct{}{})
	fake.recordInvocation("IDNode", []interface{}{})
	fake.iDNodeMutex.Unlock()
	if fake.IDNodeStub != nil {
		return fake.IDNodeStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.iDNodeReturns.result1
}

func (fake *FakeBlockNode) IDNodeCallCount() int {
	fake.iDNodeMutex.RLock()
	defer fake.iDNodeMutex.RUnlock()
	return len(fake.iDNodeArgsForCall)
}

func (fake *FakeBlockNode) IDNodeReturns(result1 parsley.Node) {
	fake.IDNodeStub = nil
	fake.iDNodeReturns = struct {
		result1 parsley.Node
	}{result1}
}

func (fake *FakeBlockNode) IDNodeReturnsOnCall(i int, result1 parsley.Node) {
	fake.IDNodeStub = nil
	if fake.iDNodeReturnsOnCall == nil {
		fake.iDNodeReturnsOnCall = make(map[int]struct {
			result1 parsley.Node
		})
	}
	fake.iDNodeReturnsOnCall[i] = struct {
		result1 parsley.Node
	}{result1}
}

func (fake *FakeBlockNode) TypeNode() parsley.Node {
	fake.typeNodeMutex.Lock()
	ret, specificReturn := fake.typeNodeReturnsOnCall[len(fake.typeNodeArgsForCall)]
	fake.typeNodeArgsForCall = append(fake.typeNodeArgsForCall, struct{}{})
	fake.recordInvocation("TypeNode", []interface{}{})
	fake.typeNodeMutex.Unlock()
	if fake.TypeNodeStub != nil {
		return fake.TypeNodeStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.typeNodeReturns.result1
}

func (fake *FakeBlockNode) TypeNodeCallCount() int {
	fake.typeNodeMutex.RLock()
	defer fake.typeNodeMutex.RUnlock()
	return len(fake.typeNodeArgsForCall)
}

func (fake *FakeBlockNode) TypeNodeReturns(result1 parsley.Node) {
	fake.TypeNodeStub = nil
	fake.typeNodeReturns = struct {
		result1 parsley.Node
	}{result1}
}

func (fake *FakeBlockNode) TypeNodeReturnsOnCall(i int, result1 parsley.Node) {
	fake.TypeNodeStub = nil
	if fake.typeNodeReturnsOnCall == nil {
		fake.typeNodeReturnsOnCall = make(map[int]struct {
			result1 parsley.Node
		})
	}
	fake.typeNodeReturnsOnCall[i] = struct {
		result1 parsley.Node
	}{result1}
}

func (fake *FakeBlockNode) ParamType(arg1 basil.ID) (string, bool) {
	fake.paramTypeMutex.Lock()
	ret, specificReturn := fake.paramTypeReturnsOnCall[len(fake.paramTypeArgsForCall)]
	fake.paramTypeArgsForCall = append(fake.paramTypeArgsForCall, struct {
		arg1 basil.ID
	}{arg1})
	fake.recordInvocation("ParamType", []interface{}{arg1})
	fake.paramTypeMutex.Unlock()
	if fake.ParamTypeStub != nil {
		return fake.ParamTypeStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.paramTypeReturns.result1, fake.paramTypeReturns.result2
}

func (fake *FakeBlockNode) ParamTypeCallCount() int {
	fake.paramTypeMutex.RLock()
	defer fake.paramTypeMutex.RUnlock()
	return len(fake.paramTypeArgsForCall)
}

func (fake *FakeBlockNode) ParamTypeArgsForCall(i int) basil.ID {
	fake.paramTypeMutex.RLock()
	defer fake.paramTypeMutex.RUnlock()
	return fake.paramTypeArgsForCall[i].arg1
}

func (fake *FakeBlockNode) ParamTypeReturns(result1 string, result2 bool) {
	fake.ParamTypeStub = nil
	fake.paramTypeReturns = struct {
		result1 string
		result2 bool
	}{result1, result2}
}

func (fake *FakeBlockNode) ParamTypeReturnsOnCall(i int, result1 string, result2 bool) {
	fake.ParamTypeStub = nil
	if fake.paramTypeReturnsOnCall == nil {
		fake.paramTypeReturnsOnCall = make(map[int]struct {
			result1 string
			result2 bool
		})
	}
	fake.paramTypeReturnsOnCall[i] = struct {
		result1 string
		result2 bool
	}{result1, result2}
}

func (fake *FakeBlockNode) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.tokenMutex.RLock()
	defer fake.tokenMutex.RUnlock()
	fake.typeMutex.RLock()
	defer fake.typeMutex.RUnlock()
	fake.valueMutex.RLock()
	defer fake.valueMutex.RUnlock()
	fake.posMutex.RLock()
	defer fake.posMutex.RUnlock()
	fake.readerPosMutex.RLock()
	defer fake.readerPosMutex.RUnlock()
	fake.childrenMutex.RLock()
	defer fake.childrenMutex.RUnlock()
	fake.iDMutex.RLock()
	defer fake.iDMutex.RUnlock()
	fake.dependenciesMutex.RLock()
	defer fake.dependenciesMutex.RUnlock()
	fake.evalStageMutex.RLock()
	defer fake.evalStageMutex.RUnlock()
	fake.iDNodeMutex.RLock()
	defer fake.iDNodeMutex.RUnlock()
	fake.typeNodeMutex.RLock()
	defer fake.typeNodeMutex.RUnlock()
	fake.paramTypeMutex.RLock()
	defer fake.paramTypeMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeBlockNode) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ basil.BlockNode = new(FakeBlockNode)
