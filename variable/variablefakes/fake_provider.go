// Code generated by counterfeiter. DO NOT EDIT.
package variablefakes

import (
	"sync"

	"github.com/opsidian/basil/variable"
)

type FakeProvider struct {
	GetVarStub        func(name variable.ID) (interface{}, bool)
	getVarMutex       sync.RWMutex
	getVarArgsForCall []struct {
		name variable.ID
	}
	getVarReturns struct {
		result1 interface{}
		result2 bool
	}
	getVarReturnsOnCall map[int]struct {
		result1 interface{}
		result2 bool
	}
	LookupVarStub        func(lookup variable.LookUp) (interface{}, error)
	lookupVarMutex       sync.RWMutex
	lookupVarArgsForCall []struct {
		lookup variable.LookUp
	}
	lookupVarReturns struct {
		result1 interface{}
		result2 error
	}
	lookupVarReturnsOnCall map[int]struct {
		result1 interface{}
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeProvider) GetVar(name variable.ID) (interface{}, bool) {
	fake.getVarMutex.Lock()
	ret, specificReturn := fake.getVarReturnsOnCall[len(fake.getVarArgsForCall)]
	fake.getVarArgsForCall = append(fake.getVarArgsForCall, struct {
		name variable.ID
	}{name})
	fake.recordInvocation("GetVar", []interface{}{name})
	fake.getVarMutex.Unlock()
	if fake.GetVarStub != nil {
		return fake.GetVarStub(name)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getVarReturns.result1, fake.getVarReturns.result2
}

func (fake *FakeProvider) GetVarCallCount() int {
	fake.getVarMutex.RLock()
	defer fake.getVarMutex.RUnlock()
	return len(fake.getVarArgsForCall)
}

func (fake *FakeProvider) GetVarArgsForCall(i int) variable.ID {
	fake.getVarMutex.RLock()
	defer fake.getVarMutex.RUnlock()
	return fake.getVarArgsForCall[i].name
}

func (fake *FakeProvider) GetVarReturns(result1 interface{}, result2 bool) {
	fake.GetVarStub = nil
	fake.getVarReturns = struct {
		result1 interface{}
		result2 bool
	}{result1, result2}
}

func (fake *FakeProvider) GetVarReturnsOnCall(i int, result1 interface{}, result2 bool) {
	fake.GetVarStub = nil
	if fake.getVarReturnsOnCall == nil {
		fake.getVarReturnsOnCall = make(map[int]struct {
			result1 interface{}
			result2 bool
		})
	}
	fake.getVarReturnsOnCall[i] = struct {
		result1 interface{}
		result2 bool
	}{result1, result2}
}

func (fake *FakeProvider) LookupVar(lookup variable.LookUp) (interface{}, error) {
	fake.lookupVarMutex.Lock()
	ret, specificReturn := fake.lookupVarReturnsOnCall[len(fake.lookupVarArgsForCall)]
	fake.lookupVarArgsForCall = append(fake.lookupVarArgsForCall, struct {
		lookup variable.LookUp
	}{lookup})
	fake.recordInvocation("LookupVar", []interface{}{lookup})
	fake.lookupVarMutex.Unlock()
	if fake.LookupVarStub != nil {
		return fake.LookupVarStub(lookup)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.lookupVarReturns.result1, fake.lookupVarReturns.result2
}

func (fake *FakeProvider) LookupVarCallCount() int {
	fake.lookupVarMutex.RLock()
	defer fake.lookupVarMutex.RUnlock()
	return len(fake.lookupVarArgsForCall)
}

func (fake *FakeProvider) LookupVarArgsForCall(i int) variable.LookUp {
	fake.lookupVarMutex.RLock()
	defer fake.lookupVarMutex.RUnlock()
	return fake.lookupVarArgsForCall[i].lookup
}

func (fake *FakeProvider) LookupVarReturns(result1 interface{}, result2 error) {
	fake.LookupVarStub = nil
	fake.lookupVarReturns = struct {
		result1 interface{}
		result2 error
	}{result1, result2}
}

func (fake *FakeProvider) LookupVarReturnsOnCall(i int, result1 interface{}, result2 error) {
	fake.LookupVarStub = nil
	if fake.lookupVarReturnsOnCall == nil {
		fake.lookupVarReturnsOnCall = make(map[int]struct {
			result1 interface{}
			result2 error
		})
	}
	fake.lookupVarReturnsOnCall[i] = struct {
		result1 interface{}
		result2 error
	}{result1, result2}
}

func (fake *FakeProvider) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.getVarMutex.RLock()
	defer fake.getVarMutex.RUnlock()
	fake.lookupVarMutex.RLock()
	defer fake.lookupVarMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeProvider) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ variable.Provider = new(FakeProvider)
