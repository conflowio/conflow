// Code generated by Basil. DO NOT EDIT.
package test

import (
	"fmt"

	"github.com/opsidian/basil/basil"
	"github.com/opsidian/basil/util"
	"github.com/opsidian/parsley/parsley"
)

type TestBlockInterpreter struct{}

func (i TestBlockInterpreter) StaticCheck(ctx interface{}, node basil.BlockNode) (string, parsley.Error) {
	validParamNames := map[basil.ID]struct{}{
		"value":               struct{}{},
		"field_string":        struct{}{},
		"field_int":           struct{}{},
		"field_float":         struct{}{},
		"field_bool":          struct{}{},
		"field_array":         struct{}{},
		"field_map":           struct{}{},
		"field_time_duration": struct{}{},
		"custom_field":        struct{}{},
		"block_nodes":         struct{}{},
	}

	for paramName, paramNode := range node.ParamNodes() {
		if _, valid := validParamNames[paramName]; !valid {
			return "", parsley.NewError(paramNode.Pos(), fmt.Errorf("%q parameter does not exist", paramName))
		}
	}

	if paramNode, ok := node.ParamNodes()["value"]; ok {
		if err := util.CheckNodeType(paramNode, "interface{}"); err != nil {
			return "", err
		}
	}

	if paramNode, ok := node.ParamNodes()["field_string"]; ok {
		if err := util.CheckNodeType(paramNode, "string"); err != nil {
			return "", err
		}
	}

	if paramNode, ok := node.ParamNodes()["field_int"]; ok {
		if err := util.CheckNodeType(paramNode, "int64"); err != nil {
			return "", err
		}
	}

	if paramNode, ok := node.ParamNodes()["field_float"]; ok {
		if err := util.CheckNodeType(paramNode, "float64"); err != nil {
			return "", err
		}
	}

	if paramNode, ok := node.ParamNodes()["field_bool"]; ok {
		if err := util.CheckNodeType(paramNode, "bool"); err != nil {
			return "", err
		}
	}

	if paramNode, ok := node.ParamNodes()["field_array"]; ok {
		if err := util.CheckNodeType(paramNode, "[]interface{}"); err != nil {
			return "", err
		}
	}

	if paramNode, ok := node.ParamNodes()["field_map"]; ok {
		if err := util.CheckNodeType(paramNode, "map[string]interface{}"); err != nil {
			return "", err
		}
	}

	if paramNode, ok := node.ParamNodes()["field_time_duration"]; ok {
		if err := util.CheckNodeType(paramNode, "time.Duration"); err != nil {
			return "", err
		}
	}

	if paramNode, ok := node.ParamNodes()["custom_field"]; ok {
		if err := util.CheckNodeType(paramNode, "string"); err != nil {
			return "", err
		}
	}

	requiredParamNames := []basil.ID{}

	for _, paramName := range requiredParamNames {
		if _, set := node.ParamNodes()[paramName]; !set {
			return "", parsley.NewError(node.Pos(), fmt.Errorf("%s parameter is required", paramName))
		}
	}

	return "*TestBlock", nil
}

// CreateBlock creates a new TestBlock block
func (i TestBlockInterpreter) Eval(parentCtx interface{}, node basil.BlockNode) (basil.Block, parsley.Error) {
	block := &TestBlock{
		IDField: node.ID(),
	}

	ctx := block.Context(parentCtx)

	for _, blockNode := range node.BlockNodes() {
		switch b := blockNode.(type) {
		case basil.BlockNode:
			block.BlockNodes = append(block.BlockNodes, b)
		}
	}

	if err := i.EvalBlock(ctx, node, "default", block); err != nil {
		return nil, err
	}

	return block, nil
}

// EvalBlock evaluates all fields belonging to the given stage on a TestBlock block
func (i TestBlockInterpreter) EvalBlock(ctx interface{}, node basil.BlockNode, stage string, res basil.Block) parsley.Error {
	var err parsley.Error

	if preInterpreter, ok := res.(basil.BlockPreInterpreter); ok {
		if err = preInterpreter.PreEval(ctx, stage); err != nil {
			return err
		}
	}

	block, ok := res.(*TestBlock)
	if !ok {
		panic("result must be a type of *TestBlock")
	}

	switch stage {
	case "default":
		if valueNode, ok := node.ParamNodes()["value"]; ok {
			if block.Value, err = util.NodeAnyValue(valueNode, ctx); err != nil {
				return err
			}
		}

		if valueNode, ok := node.ParamNodes()["field_string"]; ok {
			if block.FieldString, err = util.NodeStringValue(valueNode, ctx); err != nil {
				return err
			}
		}

		if valueNode, ok := node.ParamNodes()["field_int"]; ok {
			if block.FieldInt, err = util.NodeIntegerValue(valueNode, ctx); err != nil {
				return err
			}
		}

		if valueNode, ok := node.ParamNodes()["field_float"]; ok {
			if block.FieldFloat, err = util.NodeFloatValue(valueNode, ctx); err != nil {
				return err
			}
		}

		if valueNode, ok := node.ParamNodes()["field_bool"]; ok {
			if block.FieldBool, err = util.NodeBoolValue(valueNode, ctx); err != nil {
				return err
			}
		}

		if valueNode, ok := node.ParamNodes()["field_array"]; ok {
			if block.FieldArray, err = util.NodeArrayValue(valueNode, ctx); err != nil {
				return err
			}
		}

		if valueNode, ok := node.ParamNodes()["field_map"]; ok {
			if block.FieldMap, err = util.NodeMapValue(valueNode, ctx); err != nil {
				return err
			}
		}

		if valueNode, ok := node.ParamNodes()["field_time_duration"]; ok {
			if block.FieldTimeDuration, err = util.NodeTimeDurationValue(valueNode, ctx); err != nil {
				return err
			}
		}

		if valueNode, ok := node.ParamNodes()["custom_field"]; ok {
			if block.FieldCustomName, err = util.NodeStringValue(valueNode, ctx); err != nil {
				return err
			}
		}
	default:
		panic(fmt.Sprintf("unknown stage: %s", stage))
	}

	switch stage {
	case "default":
		var childBlock interface{}
		for _, childBlockNode := range node.BlockNodes() {
			if childBlock, err = childBlockNode.Value(ctx); err != nil {
				return err
			}

			switch b := childBlock.(type) {
			case *TestBlock:
				block.Blocks = append(block.Blocks, b)
			default:
				panic(fmt.Sprintf("block type %T is not supported in TestBlock, please open a bug ticket", childBlock))
			}

		}
	default:
		panic(fmt.Sprintf("unknown stage: %s", stage))
	}

	if postInterpreter, ok := res.(basil.BlockPostInterpreter); ok {
		if err = postInterpreter.PostEval(ctx, stage); err != nil {
			return err
		}
	}

	return nil
}

// HasForeignID returns true if the block ID is referencing an other block id
func (i TestBlockInterpreter) HasForeignID() bool {
	return false
}

// HasShortFormat returns true if the block can be defined in the short block format
func (i TestBlockInterpreter) ValueParamName() basil.ID {
	return basil.ID("value")
}

func (i TestBlockInterpreter) BlockRegistry() parsley.NodeTransformerRegistry {
	var block basil.Block = &TestBlock{}
	if b, ok := block.(basil.BlockRegistryAware); ok {
		return b.BlockRegistry()
	}

	return nil
}
