// Code generated by counterfeiter. DO NOT EDIT.
package oclfakes

import (
	"sync"

	"github.com/opsidian/ocl/ocl"
	"github.com/opsidian/parsley/parsley"
)

type FakeBlockRegistry struct {
	CreateBlockStub        func(ctx interface{}, typeNode parsley.Node, idNode parsley.Node, paramNodes map[string]parsley.Node, blockNodes []parsley.Node) (ocl.Block, parsley.Error)
	createBlockMutex       sync.RWMutex
	createBlockArgsForCall []struct {
		ctx        interface{}
		typeNode   parsley.Node
		idNode     parsley.Node
		paramNodes map[string]parsley.Node
		blockNodes []parsley.Node
	}
	createBlockReturns struct {
		result1 ocl.Block
		result2 parsley.Error
	}
	createBlockReturnsOnCall map[int]struct {
		result1 ocl.Block
		result2 parsley.Error
	}
	BlockFactoryExistsStub        func(blockType string) bool
	blockFactoryExistsMutex       sync.RWMutex
	blockFactoryExistsArgsForCall []struct {
		blockType string
	}
	blockFactoryExistsReturns struct {
		result1 bool
	}
	blockFactoryExistsReturnsOnCall map[int]struct {
		result1 bool
	}
	RegisterBlockFactoryStub        func(blockType string, factory ocl.BlockFactory)
	registerBlockFactoryMutex       sync.RWMutex
	registerBlockFactoryArgsForCall []struct {
		blockType string
		factory   ocl.BlockFactory
	}
	BlockIDExistsStub        func(string) bool
	blockIDExistsMutex       sync.RWMutex
	blockIDExistsArgsForCall []struct {
		arg1 string
	}
	blockIDExistsReturns struct {
		result1 bool
	}
	blockIDExistsReturnsOnCall map[int]struct {
		result1 bool
	}
	GenerateBlockIDStub        func() string
	generateBlockIDMutex       sync.RWMutex
	generateBlockIDArgsForCall []struct{}
	generateBlockIDReturns     struct {
		result1 string
	}
	generateBlockIDReturnsOnCall map[int]struct {
		result1 string
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeBlockRegistry) CreateBlock(ctx interface{}, typeNode parsley.Node, idNode parsley.Node, paramNodes map[string]parsley.Node, blockNodes []parsley.Node) (ocl.Block, parsley.Error) {
	var blockNodesCopy []parsley.Node
	if blockNodes != nil {
		blockNodesCopy = make([]parsley.Node, len(blockNodes))
		copy(blockNodesCopy, blockNodes)
	}
	fake.createBlockMutex.Lock()
	ret, specificReturn := fake.createBlockReturnsOnCall[len(fake.createBlockArgsForCall)]
	fake.createBlockArgsForCall = append(fake.createBlockArgsForCall, struct {
		ctx        interface{}
		typeNode   parsley.Node
		idNode     parsley.Node
		paramNodes map[string]parsley.Node
		blockNodes []parsley.Node
	}{ctx, typeNode, idNode, paramNodes, blockNodesCopy})
	fake.recordInvocation("CreateBlock", []interface{}{ctx, typeNode, idNode, paramNodes, blockNodesCopy})
	fake.createBlockMutex.Unlock()
	if fake.CreateBlockStub != nil {
		return fake.CreateBlockStub(ctx, typeNode, idNode, paramNodes, blockNodes)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.createBlockReturns.result1, fake.createBlockReturns.result2
}

func (fake *FakeBlockRegistry) CreateBlockCallCount() int {
	fake.createBlockMutex.RLock()
	defer fake.createBlockMutex.RUnlock()
	return len(fake.createBlockArgsForCall)
}

func (fake *FakeBlockRegistry) CreateBlockArgsForCall(i int) (interface{}, parsley.Node, parsley.Node, map[string]parsley.Node, []parsley.Node) {
	fake.createBlockMutex.RLock()
	defer fake.createBlockMutex.RUnlock()
	return fake.createBlockArgsForCall[i].ctx, fake.createBlockArgsForCall[i].typeNode, fake.createBlockArgsForCall[i].idNode, fake.createBlockArgsForCall[i].paramNodes, fake.createBlockArgsForCall[i].blockNodes
}

func (fake *FakeBlockRegistry) CreateBlockReturns(result1 ocl.Block, result2 parsley.Error) {
	fake.CreateBlockStub = nil
	fake.createBlockReturns = struct {
		result1 ocl.Block
		result2 parsley.Error
	}{result1, result2}
}

func (fake *FakeBlockRegistry) CreateBlockReturnsOnCall(i int, result1 ocl.Block, result2 parsley.Error) {
	fake.CreateBlockStub = nil
	if fake.createBlockReturnsOnCall == nil {
		fake.createBlockReturnsOnCall = make(map[int]struct {
			result1 ocl.Block
			result2 parsley.Error
		})
	}
	fake.createBlockReturnsOnCall[i] = struct {
		result1 ocl.Block
		result2 parsley.Error
	}{result1, result2}
}

func (fake *FakeBlockRegistry) BlockFactoryExists(blockType string) bool {
	fake.blockFactoryExistsMutex.Lock()
	ret, specificReturn := fake.blockFactoryExistsReturnsOnCall[len(fake.blockFactoryExistsArgsForCall)]
	fake.blockFactoryExistsArgsForCall = append(fake.blockFactoryExistsArgsForCall, struct {
		blockType string
	}{blockType})
	fake.recordInvocation("BlockFactoryExists", []interface{}{blockType})
	fake.blockFactoryExistsMutex.Unlock()
	if fake.BlockFactoryExistsStub != nil {
		return fake.BlockFactoryExistsStub(blockType)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.blockFactoryExistsReturns.result1
}

func (fake *FakeBlockRegistry) BlockFactoryExistsCallCount() int {
	fake.blockFactoryExistsMutex.RLock()
	defer fake.blockFactoryExistsMutex.RUnlock()
	return len(fake.blockFactoryExistsArgsForCall)
}

func (fake *FakeBlockRegistry) BlockFactoryExistsArgsForCall(i int) string {
	fake.blockFactoryExistsMutex.RLock()
	defer fake.blockFactoryExistsMutex.RUnlock()
	return fake.blockFactoryExistsArgsForCall[i].blockType
}

func (fake *FakeBlockRegistry) BlockFactoryExistsReturns(result1 bool) {
	fake.BlockFactoryExistsStub = nil
	fake.blockFactoryExistsReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeBlockRegistry) BlockFactoryExistsReturnsOnCall(i int, result1 bool) {
	fake.BlockFactoryExistsStub = nil
	if fake.blockFactoryExistsReturnsOnCall == nil {
		fake.blockFactoryExistsReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.blockFactoryExistsReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeBlockRegistry) RegisterBlockFactory(blockType string, factory ocl.BlockFactory) {
	fake.registerBlockFactoryMutex.Lock()
	fake.registerBlockFactoryArgsForCall = append(fake.registerBlockFactoryArgsForCall, struct {
		blockType string
		factory   ocl.BlockFactory
	}{blockType, factory})
	fake.recordInvocation("RegisterBlockFactory", []interface{}{blockType, factory})
	fake.registerBlockFactoryMutex.Unlock()
	if fake.RegisterBlockFactoryStub != nil {
		fake.RegisterBlockFactoryStub(blockType, factory)
	}
}

func (fake *FakeBlockRegistry) RegisterBlockFactoryCallCount() int {
	fake.registerBlockFactoryMutex.RLock()
	defer fake.registerBlockFactoryMutex.RUnlock()
	return len(fake.registerBlockFactoryArgsForCall)
}

func (fake *FakeBlockRegistry) RegisterBlockFactoryArgsForCall(i int) (string, ocl.BlockFactory) {
	fake.registerBlockFactoryMutex.RLock()
	defer fake.registerBlockFactoryMutex.RUnlock()
	return fake.registerBlockFactoryArgsForCall[i].blockType, fake.registerBlockFactoryArgsForCall[i].factory
}

func (fake *FakeBlockRegistry) BlockIDExists(arg1 string) bool {
	fake.blockIDExistsMutex.Lock()
	ret, specificReturn := fake.blockIDExistsReturnsOnCall[len(fake.blockIDExistsArgsForCall)]
	fake.blockIDExistsArgsForCall = append(fake.blockIDExistsArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("BlockIDExists", []interface{}{arg1})
	fake.blockIDExistsMutex.Unlock()
	if fake.BlockIDExistsStub != nil {
		return fake.BlockIDExistsStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.blockIDExistsReturns.result1
}

func (fake *FakeBlockRegistry) BlockIDExistsCallCount() int {
	fake.blockIDExistsMutex.RLock()
	defer fake.blockIDExistsMutex.RUnlock()
	return len(fake.blockIDExistsArgsForCall)
}

func (fake *FakeBlockRegistry) BlockIDExistsArgsForCall(i int) string {
	fake.blockIDExistsMutex.RLock()
	defer fake.blockIDExistsMutex.RUnlock()
	return fake.blockIDExistsArgsForCall[i].arg1
}

func (fake *FakeBlockRegistry) BlockIDExistsReturns(result1 bool) {
	fake.BlockIDExistsStub = nil
	fake.blockIDExistsReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeBlockRegistry) BlockIDExistsReturnsOnCall(i int, result1 bool) {
	fake.BlockIDExistsStub = nil
	if fake.blockIDExistsReturnsOnCall == nil {
		fake.blockIDExistsReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.blockIDExistsReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeBlockRegistry) GenerateBlockID() string {
	fake.generateBlockIDMutex.Lock()
	ret, specificReturn := fake.generateBlockIDReturnsOnCall[len(fake.generateBlockIDArgsForCall)]
	fake.generateBlockIDArgsForCall = append(fake.generateBlockIDArgsForCall, struct{}{})
	fake.recordInvocation("GenerateBlockID", []interface{}{})
	fake.generateBlockIDMutex.Unlock()
	if fake.GenerateBlockIDStub != nil {
		return fake.GenerateBlockIDStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.generateBlockIDReturns.result1
}

func (fake *FakeBlockRegistry) GenerateBlockIDCallCount() int {
	fake.generateBlockIDMutex.RLock()
	defer fake.generateBlockIDMutex.RUnlock()
	return len(fake.generateBlockIDArgsForCall)
}

func (fake *FakeBlockRegistry) GenerateBlockIDReturns(result1 string) {
	fake.GenerateBlockIDStub = nil
	fake.generateBlockIDReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeBlockRegistry) GenerateBlockIDReturnsOnCall(i int, result1 string) {
	fake.GenerateBlockIDStub = nil
	if fake.generateBlockIDReturnsOnCall == nil {
		fake.generateBlockIDReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.generateBlockIDReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeBlockRegistry) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.createBlockMutex.RLock()
	defer fake.createBlockMutex.RUnlock()
	fake.blockFactoryExistsMutex.RLock()
	defer fake.blockFactoryExistsMutex.RUnlock()
	fake.registerBlockFactoryMutex.RLock()
	defer fake.registerBlockFactoryMutex.RUnlock()
	fake.blockIDExistsMutex.RLock()
	defer fake.blockIDExistsMutex.RUnlock()
	fake.generateBlockIDMutex.RLock()
	defer fake.generateBlockIDMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeBlockRegistry) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ ocl.BlockRegistry = new(FakeBlockRegistry)
